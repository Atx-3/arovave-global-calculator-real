"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/lib/calculator.js":
/*!*******************************!*\
  !*** ./src/lib/calculator.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateContainers: function() { return /* binding */ calculateContainers; },\n/* harmony export */   calculateCostHeads: function() { return /* binding */ calculateCostHeads; },\n/* harmony export */   calculateExportPricing: function() { return /* binding */ calculateExportPricing; },\n/* harmony export */   convertToINR: function() { return /* binding */ convertToINR; },\n/* harmony export */   convertToUSD: function() { return /* binding */ convertToUSD; },\n/* harmony export */   formatINR: function() { return /* binding */ formatINR; },\n/* harmony export */   formatNumber: function() { return /* binding */ formatNumber; },\n/* harmony export */   formatPercent: function() { return /* binding */ formatPercent; },\n/* harmony export */   formatUSD: function() { return /* binding */ formatUSD; }\n/* harmony export */ });\n/**\r\n * AROVAVE GLOBAL - Export Rate Calculator Engine v2\r\n * Container-Based FCL Export Pricing System\r\n * \r\n * Calculation Flow:\r\n * EX-FACTORY → Container Count → Local Freight → Handling → Port → FOB\r\n * → ECGC → Int'l Freight → Currency → Insurance → Bank → Profit → CIF\r\n */ // ============================================\n// CONTAINER CALCULATION\n// ============================================\n/**\r\n * Calculate number of containers required\r\n * @param {number} quantity - Total quantity ordered\r\n * @param {number} qtyPerContainer - How much fits in 1 container (user defined)\r\n * @returns {number} Number of containers needed\r\n */ function calculateContainers(quantity, qtyPerContainer) {\n    if (!quantity || !qtyPerContainer || qtyPerContainer <= 0) {\n        return 1;\n    }\n    return Math.ceil(quantity / qtyPerContainer);\n}\n// ============================================\n// CURRENCY CONVERSION\n// ============================================\n/**\r\n * Convert foreign currency to INR with bank margin\r\n * @param {number} amount - Amount in foreign currency\r\n * @param {number} exchangeRate - Base exchange rate to INR\r\n * @param {number} bankMargin - Bank's margin (e.g., 0.50)\r\n * @returns {number} Amount in INR\r\n */ function convertToINR(amount, exchangeRate) {\n    let bankMargin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    const effectiveRate = exchangeRate + bankMargin;\n    return amount * effectiveRate;\n}\n/**\r\n * Convert INR to USD for display\r\n * @param {number} amountINR\r\n * @param {number} usdRate\r\n * @returns {number}\r\n */ function convertToUSD(amountINR, usdRate) {\n    if (!usdRate || usdRate <= 0) return 0;\n    return amountINR / usdRate;\n}\n// ============================================\n// COST AGGREGATION\n// ============================================\n/**\r\n * Calculate costs based on charge type\r\n * @param {Array} costHeads - Array of cost head objects\r\n * @param {number} containerCount - Number of containers\r\n * @param {number} quantity - Total quantity\r\n * @param {number} baseValue - Base value for percentage calculations\r\n * @returns {Object} Categorized costs\r\n */ function calculateCostHeads(costHeads, containerCount, quantity) {\n    let baseValue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n    let perShipmentTotal = 0;\n    let perContainerTotal = 0;\n    const breakdown = [];\n    costHeads.forEach((cost)=>{\n        if (!cost.is_active) return;\n        let amount = 0;\n        let displayAmount = 0;\n        if (cost.calculation_base === \"percentage\") {\n            amount = baseValue * (cost.percentage_rate / 100);\n            displayAmount = amount;\n        } else {\n            amount = parseFloat(cost.base_amount) || 0;\n            if (cost.charge_type === \"per_container\") {\n                displayAmount = amount * containerCount;\n                perContainerTotal += displayAmount;\n            } else if (cost.charge_type === \"per_unit\") {\n                displayAmount = amount * quantity;\n                perShipmentTotal += displayAmount;\n            } else {\n                // per_shipment\n                displayAmount = amount;\n                perShipmentTotal += displayAmount;\n            }\n        }\n        if (displayAmount > 0) {\n            breakdown.push({\n                name: cost.name,\n                chargeType: cost.charge_type,\n                unitAmount: amount,\n                quantity: cost.charge_type === \"per_container\" ? containerCount : 1,\n                total: displayAmount\n            });\n        }\n    });\n    return {\n        perShipment: roundToTwo(perShipmentTotal),\n        perContainer: roundToTwo(perContainerTotal),\n        total: roundToTwo(perShipmentTotal + perContainerTotal),\n        breakdown\n    };\n}\n// ============================================\n// MAIN CALCULATION ENGINE\n// ============================================\n/**\r\n * Complete export pricing calculation\r\n * @param {Object} params - All input parameters\r\n * @returns {Object} Complete pricing breakdown\r\n */ function calculateExportPricing(param) {\n    let { // Product & Quantity\n    product, quantity, // Container\n    containerType, qtyPerContainer, // Locations\n    localFreightRate, // Port charges\n    portHandlingPerContainer, chaCharges, customsClearance, // Cost heads\n    costHeads = [], // Certifications\n    certifications = [], // International Freight\n    freightRate, freightCurrency = \"USD\", freightConversionRate = 1.0, freightGST = 5, // Currency settings\n    exchangeRate = 83.50, bankMargin = 0.50, // ECGC\n    ecgcRate = 0.50, // Insurance\n    insuranceRate = 0.50, minInsurance = 5000, // Bank charges\n    bankChargeRate = 0.25, // Profit\n    profitRate = 5.0, profitType = \"percentage\", // Display currency\n    displayCurrency = \"USD\", // Selected pricing tier: 'exFactory', 'fob', or 'cif'\n    // Profit will be calculated at the selected tier\n    selectedTier = \"cif\", // Custom charges (in INR)\n    packagingCharges = 0, extraCharges = 0 } = param;\n    // ============================================\n    // STEP 1: CONTAINER CALCULATION\n    // ============================================\n    const containerCount = calculateContainers(quantity, qtyPerContainer);\n    // ============================================\n    // STEP 2: PACKAGING CHARGES (per box, added to product cost)\n    // ============================================\n    const totalPackagingCharges = parseFloat(packagingCharges) || 0;\n    const totalExtraChargesAmount = parseFloat(extraCharges) || 0;\n    const customChargesTotal = totalPackagingCharges + totalExtraChargesAmount;\n    // ============================================\n    // STEP 3: EX-FACTORY COST (Product + Packaging)\n    // ============================================\n    const basePrice = parseFloat(product.base_price_usd) || 0;\n    const exFactoryProductUSD = basePrice * quantity;\n    const exFactoryProductINR = convertToINR(exFactoryProductUSD, exchangeRate, 0);\n    // Add packaging and extra charges to Ex-Factory\n    const exFactoryINR = exFactoryProductINR + customChargesTotal;\n    const exFactoryUSD = convertToUSD(exFactoryINR, exchangeRate);\n    // ============================================\n    // STEP 3: LOCAL FREIGHT (Per Container)\n    // ============================================\n    const localFreightPerContainer = parseFloat(localFreightRate) || 0;\n    const localFreightTotal = localFreightPerContainer * containerCount;\n    // ============================================\n    // STEP 4: HANDLING & LABOUR (From Cost Heads)\n    // ============================================\n    const handlingCosts = calculateCostHeads(costHeads.filter((c)=>c.category === \"handling\"), containerCount, quantity, exFactoryINR);\n    // ============================================\n    // STEP 5: PORT CHARGES\n    // ============================================\n    const portHandlingTotal = (parseFloat(portHandlingPerContainer) || 0) * containerCount;\n    const chaTotal = parseFloat(chaCharges) || 0; // Per shipment\n    const customsTotal = parseFloat(customsClearance) || 0; // Per shipment\n    const portCosts = {\n        handling: portHandlingTotal,\n        cha: chaTotal,\n        customs: customsTotal,\n        total: portHandlingTotal + chaTotal + customsTotal\n    };\n    // ============================================\n    // STEP 6: MISCELLANEOUS CHARGES\n    // ============================================\n    const miscCosts = calculateCostHeads(costHeads.filter((c)=>c.category === \"misc\"), containerCount, quantity, exFactoryINR);\n    // ============================================\n    // STEP 7: CERTIFICATIONS\n    // ============================================\n    let certificationTotal = 0;\n    const certBreakdown = [];\n    certifications.forEach((cert)=>{\n        let cost = 0;\n        if (cert.cost_percentage > 0) {\n            cost = exFactoryINR * (cert.cost_percentage / 100);\n        } else {\n            cost = parseFloat(cert.cost_flat) || 0;\n            if (cert.charge_type === \"per_container\") {\n                cost = cost * containerCount;\n            }\n        }\n        certificationTotal += cost;\n        if (cost > 0) {\n            certBreakdown.push({\n                name: cert.name,\n                cost: roundToTwo(cost)\n            });\n        }\n    });\n    // ============================================\n    // STEP 8: FOB CALCULATION\n    // ============================================\n    // Note: Packaging and extra charges are already included in exFactoryINR\n    const fobINR = exFactoryINR + localFreightTotal + handlingCosts.total + portCosts.total + miscCosts.total + certificationTotal;\n    const fobUSD = convertToUSD(fobINR, exchangeRate);\n    // ============================================\n    // STEP 9: ECGC (Export Credit Guarantee)\n    // ============================================\n    const ecgcAmount = fobINR * (ecgcRate / 100);\n    // ============================================\n    // STEP 10: INTERNATIONAL FREIGHT\n    // ============================================\n    const freightPerContainer = parseFloat(freightRate) || 0;\n    const freightTotalForeign = freightPerContainer * containerCount;\n    // Apply freight conversion rate\n    const freightAdjusted = freightTotalForeign * (parseFloat(freightConversionRate) || 1);\n    // Convert to INR with bank margin\n    const freightINR = convertToINR(freightAdjusted, exchangeRate, bankMargin);\n    // Add GST on freight\n    const freightGSTAmount = freightINR * (freightGST / 100);\n    const freightWithGST = freightINR + freightGSTAmount;\n    // ============================================\n    // STEP 11: INSURANCE\n    // ============================================\n    // Insurance is calculated on CIF, so we need iterative calculation\n    // CIF = FOB + Freight + Insurance\n    // Insurance = InsuranceRate% × CIF\n    // So: Insurance = InsuranceRate% × (FOB + Freight + Insurance)\n    // Insurance × (1 - InsuranceRate%) = InsuranceRate% × (FOB + Freight)\n    // Insurance = (InsuranceRate% × (FOB + Freight)) / (1 - InsuranceRate%)\n    const preCifBase = fobINR + ecgcAmount + freightWithGST;\n    let insuranceAmount = preCifBase * (insuranceRate / 100) / (1 - insuranceRate / 100);\n    if (insuranceAmount < minInsurance) {\n        insuranceAmount = minInsurance;\n    }\n    // ============================================\n    // STEP 12: BANK CHARGES\n    // ============================================\n    const invoiceValue = preCifBase + insuranceAmount;\n    const bankCharges = invoiceValue * (bankChargeRate / 100);\n    // ============================================\n    // STEP 13: PROFIT MARGIN (Applied at selected tier)\n    // ============================================\n    const costBaseCIF = invoiceValue + bankCharges;\n    // Calculate profit base based on selected tier\n    let profitBase = 0;\n    if (selectedTier === \"exFactory\") {\n        profitBase = exFactoryINR;\n    } else if (selectedTier === \"fob\") {\n        profitBase = fobINR;\n    } else {\n        // CIF - use full cost base\n        profitBase = costBaseCIF;\n    }\n    let profitAmount = 0;\n    if (profitType === \"percentage\") {\n        profitAmount = profitBase * (profitRate / 100);\n    } else if (profitType === \"per_container\") {\n        profitAmount = profitRate * containerCount;\n    } else if (profitType === \"per_unit\") {\n        profitAmount = profitRate * quantity;\n    } else {\n        profitAmount = profitRate; // Fixed amount\n    }\n    // ============================================\n    // STEP 14: FINAL PRICES WITH PROFIT AT SELECTED TIER\n    // ============================================\n    // Calculate final prices based on selected tier\n    let exFactoryFinalINR = exFactoryINR;\n    let fobFinalINR = fobINR;\n    let cifFinalINR = costBaseCIF;\n    if (selectedTier === \"exFactory\") {\n        // Profit added to Ex Factory only\n        exFactoryFinalINR = exFactoryINR + profitAmount;\n        fobFinalINR = fobINR; // No profit in FOB/CIF\n        cifFinalINR = costBaseCIF;\n    } else if (selectedTier === \"fob\") {\n        // Profit added to FOB\n        exFactoryFinalINR = exFactoryINR;\n        fobFinalINR = fobINR + profitAmount;\n        cifFinalINR = costBaseCIF;\n    } else {\n        // CIF - profit added to full cost (current behavior)\n        exFactoryFinalINR = exFactoryINR;\n        fobFinalINR = fobINR;\n        cifFinalINR = costBaseCIF + profitAmount;\n    }\n    const exFactoryFinalUSD = convertToUSD(exFactoryFinalINR, exchangeRate);\n    const fobFinalUSD = convertToUSD(fobFinalINR, exchangeRate);\n    const cifFinalUSD = convertToUSD(cifFinalINR, exchangeRate);\n    // ============================================\n    // RETURN COMPLETE BREAKDOWN\n    // ============================================\n    return {\n        // Container info\n        containerType: (containerType === null || containerType === void 0 ? void 0 : containerType.name) || \"N/A\",\n        containerCode: (containerType === null || containerType === void 0 ? void 0 : containerType.code) || \"N/A\",\n        qtyPerContainer,\n        containerCount,\n        // Selected pricing tier info\n        selectedTier,\n        tierLabels: {\n            exFactory: \"Ex Factory\",\n            fob: \"FOB (Free on Board)\",\n            cif: \"CIF (Cost Insurance Freight)\"\n        },\n        // Main prices (with profit applied at selected tier)\n        exFactory: {\n            inr: roundToTwo(exFactoryFinalINR),\n            usd: roundToTwo(exFactoryFinalUSD),\n            baseInr: roundToTwo(exFactoryINR),\n            baseUsd: roundToTwo(exFactoryUSD)\n        },\n        fob: {\n            inr: roundToTwo(fobFinalINR),\n            usd: roundToTwo(fobFinalUSD),\n            baseInr: roundToTwo(fobINR),\n            baseUsd: roundToTwo(fobUSD)\n        },\n        cif: {\n            inr: roundToTwo(cifFinalINR),\n            usd: roundToTwo(cifFinalUSD),\n            baseInr: roundToTwo(costBaseCIF),\n            baseUsd: roundToTwo(convertToUSD(costBaseCIF, exchangeRate))\n        },\n        // Per unit prices (using final prices with profit)\n        perUnit: {\n            exFactory: roundToTwo(exFactoryFinalUSD / quantity),\n            fob: roundToTwo(fobFinalUSD / quantity),\n            cif: roundToTwo(cifFinalUSD / quantity)\n        },\n        // Detailed breakdown\n        breakdown: {\n            productBase: {\n                label: \"Product Base Price\",\n                perUnit: basePrice,\n                quantity,\n                total: roundToTwo(exFactoryProductINR),\n                chargeType: \"per_unit\"\n            },\n            packagingCharges: {\n                label: \"Packaging & Extra Charges\",\n                total: roundToTwo(customChargesTotal),\n                chargeType: \"flat\"\n            },\n            localFreight: {\n                label: \"Local Freight\",\n                perContainer: localFreightPerContainer,\n                containers: containerCount,\n                total: roundToTwo(localFreightTotal),\n                chargeType: \"per_container\"\n            },\n            handling: handlingCosts,\n            port: {\n                label: \"Port Charges\",\n                handling: roundToTwo(portHandlingTotal),\n                cha: roundToTwo(chaTotal),\n                customs: roundToTwo(customsTotal),\n                total: roundToTwo(portCosts.total),\n                chargeType: \"mixed\"\n            },\n            misc: miscCosts,\n            certifications: {\n                items: certBreakdown,\n                total: roundToTwo(certificationTotal)\n            },\n            ecgc: {\n                label: \"ECGC Premium\",\n                rate: ecgcRate,\n                total: roundToTwo(ecgcAmount),\n                chargeType: \"percentage\"\n            },\n            freight: {\n                label: \"International Freight\",\n                perContainer: freightPerContainer,\n                containers: containerCount,\n                currency: freightCurrency,\n                foreignTotal: roundToTwo(freightTotalForeign),\n                conversionRate: freightConversionRate,\n                exchangeRate: exchangeRate + bankMargin,\n                inrTotal: roundToTwo(freightINR),\n                gstRate: freightGST,\n                gstAmount: roundToTwo(freightGSTAmount),\n                totalWithGST: roundToTwo(freightWithGST),\n                chargeType: \"per_container\"\n            },\n            insurance: {\n                label: \"Marine Insurance\",\n                rate: insuranceRate,\n                total: roundToTwo(insuranceAmount),\n                chargeType: \"percentage\"\n            },\n            bankCharges: {\n                label: \"Bank Charges\",\n                rate: bankChargeRate,\n                total: roundToTwo(bankCharges),\n                chargeType: \"percentage\"\n            },\n            profit: {\n                label: \"Company Margin\",\n                type: profitType,\n                rate: profitRate,\n                total: roundToTwo(profitAmount)\n            }\n        },\n        // Summary by charge type\n        summary: {\n            perShipmentCosts: roundToTwo(handlingCosts.perShipment + chaTotal + customsTotal + miscCosts.perShipment + certificationTotal + ecgcAmount + insuranceAmount + bankCharges + profitAmount),\n            perContainerCosts: roundToTwo(localFreightTotal + handlingCosts.perContainer + portHandlingTotal + miscCosts.perContainer + freightWithGST)\n        },\n        // Currency info\n        currency: {\n            exchange: exchangeRate,\n            bankMargin,\n            effective: exchangeRate + bankMargin\n        }\n    };\n}\n// ============================================\n// UTILITY FUNCTIONS\n// ============================================\n/**\r\n * Round to 2 decimal places\r\n */ function roundToTwo(value) {\n    return Math.round((value || 0) * 100) / 100;\n}\n/**\r\n * Format currency (INR)\r\n */ function formatINR(amount) {\n    return new Intl.NumberFormat(\"en-IN\", {\n        style: \"currency\",\n        currency: \"INR\",\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).format(amount || 0);\n}\n/**\r\n * Format currency (USD)\r\n */ function formatUSD(amount) {\n    return new Intl.NumberFormat(\"en-US\", {\n        style: \"currency\",\n        currency: \"USD\",\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).format(amount || 0);\n}\n/**\r\n * Format number with commas (Indian style)\r\n */ function formatNumber(num) {\n    return new Intl.NumberFormat(\"en-IN\").format(num || 0);\n}\n/**\r\n * Format as percentage\r\n */ function formatPercent(rate) {\n    return \"\".concat(rate, \"%\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxTQUFTSSxNQUFNLENBQUNHLE9BQU87QUFDeEQ7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLGNBQWM3QixJQUFJO0lBQzlCLE9BQU8sR0FBUSxPQUFMQSxNQUFLO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvY2FsY3VsYXRvci5qcz8zYzI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBUk9WQVZFIEdMT0JBTCAtIEV4cG9ydCBSYXRlIENhbGN1bGF0b3IgRW5naW5lIHYyXHJcbiAqIENvbnRhaW5lci1CYXNlZCBGQ0wgRXhwb3J0IFByaWNpbmcgU3lzdGVtXHJcbiAqIFxyXG4gKiBDYWxjdWxhdGlvbiBGbG93OlxyXG4gKiBFWC1GQUNUT1JZIOKGkiBDb250YWluZXIgQ291bnQg4oaSIExvY2FsIEZyZWlnaHQg4oaSIEhhbmRsaW5nIOKGkiBQb3J0IOKGkiBGT0JcclxuICog4oaSIEVDR0Mg4oaSIEludCdsIEZyZWlnaHQg4oaSIEN1cnJlbmN5IOKGkiBJbnN1cmFuY2Ug4oaSIEJhbmsg4oaSIFByb2ZpdCDihpIgQ0lGXHJcbiAqL1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gQ09OVEFJTkVSIENBTENVTEFUSU9OXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIG51bWJlciBvZiBjb250YWluZXJzIHJlcXVpcmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBxdWFudGl0eSAtIFRvdGFsIHF1YW50aXR5IG9yZGVyZWRcclxuICogQHBhcmFtIHtudW1iZXJ9IHF0eVBlckNvbnRhaW5lciAtIEhvdyBtdWNoIGZpdHMgaW4gMSBjb250YWluZXIgKHVzZXIgZGVmaW5lZClcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGNvbnRhaW5lcnMgbmVlZGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQ29udGFpbmVycyhxdWFudGl0eSwgcXR5UGVyQ29udGFpbmVyKSB7XHJcbiAgICBpZiAoIXF1YW50aXR5IHx8ICFxdHlQZXJDb250YWluZXIgfHwgcXR5UGVyQ29udGFpbmVyIDw9IDApIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBNYXRoLmNlaWwocXVhbnRpdHkgLyBxdHlQZXJDb250YWluZXIpO1xyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBDVVJSRU5DWSBDT05WRVJTSU9OXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4vKipcclxuICogQ29udmVydCBmb3JlaWduIGN1cnJlbmN5IHRvIElOUiB3aXRoIGJhbmsgbWFyZ2luXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBBbW91bnQgaW4gZm9yZWlnbiBjdXJyZW5jeVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhjaGFuZ2VSYXRlIC0gQmFzZSBleGNoYW5nZSByYXRlIHRvIElOUlxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFua01hcmdpbiAtIEJhbmsncyBtYXJnaW4gKGUuZy4sIDAuNTApXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEFtb3VudCBpbiBJTlJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9JTlIoYW1vdW50LCBleGNoYW5nZVJhdGUsIGJhbmtNYXJnaW4gPSAwKSB7XHJcbiAgICBjb25zdCBlZmZlY3RpdmVSYXRlID0gZXhjaGFuZ2VSYXRlICsgYmFua01hcmdpbjtcclxuICAgIHJldHVybiBhbW91bnQgKiBlZmZlY3RpdmVSYXRlO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBJTlIgdG8gVVNEIGZvciBkaXNwbGF5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnRJTlJcclxuICogQHBhcmFtIHtudW1iZXJ9IHVzZFJhdGVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9VU0QoYW1vdW50SU5SLCB1c2RSYXRlKSB7XHJcbiAgICBpZiAoIXVzZFJhdGUgfHwgdXNkUmF0ZSA8PSAwKSByZXR1cm4gMDtcclxuICAgIHJldHVybiBhbW91bnRJTlIgLyB1c2RSYXRlO1xyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBDT1NUIEFHR1JFR0FUSU9OXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIGNvc3RzIGJhc2VkIG9uIGNoYXJnZSB0eXBlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGNvc3RIZWFkcyAtIEFycmF5IG9mIGNvc3QgaGVhZCBvYmplY3RzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250YWluZXJDb3VudCAtIE51bWJlciBvZiBjb250YWluZXJzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBxdWFudGl0eSAtIFRvdGFsIHF1YW50aXR5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlVmFsdWUgLSBCYXNlIHZhbHVlIGZvciBwZXJjZW50YWdlIGNhbGN1bGF0aW9uc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDYXRlZ29yaXplZCBjb3N0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvc3RIZWFkcyhjb3N0SGVhZHMsIGNvbnRhaW5lckNvdW50LCBxdWFudGl0eSwgYmFzZVZhbHVlID0gMCkge1xyXG4gICAgbGV0IHBlclNoaXBtZW50VG90YWwgPSAwO1xyXG4gICAgbGV0IHBlckNvbnRhaW5lclRvdGFsID0gMDtcclxuICAgIGNvbnN0IGJyZWFrZG93biA9IFtdO1xyXG5cclxuICAgIGNvc3RIZWFkcy5mb3JFYWNoKGNvc3QgPT4ge1xyXG4gICAgICAgIGlmICghY29zdC5pc19hY3RpdmUpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGFtb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IGRpc3BsYXlBbW91bnQgPSAwO1xyXG5cclxuICAgICAgICBpZiAoY29zdC5jYWxjdWxhdGlvbl9iYXNlID09PSAncGVyY2VudGFnZScpIHtcclxuICAgICAgICAgICAgYW1vdW50ID0gYmFzZVZhbHVlICogKGNvc3QucGVyY2VudGFnZV9yYXRlIC8gMTAwKTtcclxuICAgICAgICAgICAgZGlzcGxheUFtb3VudCA9IGFtb3VudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhbW91bnQgPSBwYXJzZUZsb2F0KGNvc3QuYmFzZV9hbW91bnQpIHx8IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29zdC5jaGFyZ2VfdHlwZSA9PT0gJ3Blcl9jb250YWluZXInKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5QW1vdW50ID0gYW1vdW50ICogY29udGFpbmVyQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBwZXJDb250YWluZXJUb3RhbCArPSBkaXNwbGF5QW1vdW50O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvc3QuY2hhcmdlX3R5cGUgPT09ICdwZXJfdW5pdCcpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlBbW91bnQgPSBhbW91bnQgKiBxdWFudGl0eTtcclxuICAgICAgICAgICAgICAgIHBlclNoaXBtZW50VG90YWwgKz0gZGlzcGxheUFtb3VudDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHBlcl9zaGlwbWVudFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheUFtb3VudCA9IGFtb3VudDtcclxuICAgICAgICAgICAgICAgIHBlclNoaXBtZW50VG90YWwgKz0gZGlzcGxheUFtb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpc3BsYXlBbW91bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGJyZWFrZG93bi5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGNvc3QubmFtZSxcclxuICAgICAgICAgICAgICAgIGNoYXJnZVR5cGU6IGNvc3QuY2hhcmdlX3R5cGUsXHJcbiAgICAgICAgICAgICAgICB1bml0QW1vdW50OiBhbW91bnQsXHJcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogY29zdC5jaGFyZ2VfdHlwZSA9PT0gJ3Blcl9jb250YWluZXInID8gY29udGFpbmVyQ291bnQgOiAxLFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IGRpc3BsYXlBbW91bnRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwZXJTaGlwbWVudDogcm91bmRUb1R3byhwZXJTaGlwbWVudFRvdGFsKSxcclxuICAgICAgICBwZXJDb250YWluZXI6IHJvdW5kVG9Ud28ocGVyQ29udGFpbmVyVG90YWwpLFxyXG4gICAgICAgIHRvdGFsOiByb3VuZFRvVHdvKHBlclNoaXBtZW50VG90YWwgKyBwZXJDb250YWluZXJUb3RhbCksXHJcbiAgICAgICAgYnJlYWtkb3duXHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBNQUlOIENBTENVTEFUSU9OIEVOR0lORVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuLyoqXHJcbiAqIENvbXBsZXRlIGV4cG9ydCBwcmljaW5nIGNhbGN1bGF0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBBbGwgaW5wdXQgcGFyYW1ldGVyc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb21wbGV0ZSBwcmljaW5nIGJyZWFrZG93blxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUV4cG9ydFByaWNpbmcoe1xyXG4gICAgLy8gUHJvZHVjdCAmIFF1YW50aXR5XHJcbiAgICBwcm9kdWN0LFxyXG4gICAgcXVhbnRpdHksXHJcblxyXG4gICAgLy8gQ29udGFpbmVyXHJcbiAgICBjb250YWluZXJUeXBlLFxyXG4gICAgcXR5UGVyQ29udGFpbmVyLFxyXG5cclxuICAgIC8vIExvY2F0aW9uc1xyXG4gICAgbG9jYWxGcmVpZ2h0UmF0ZSwgIC8vIFJhdGUgcGVyIGNvbnRhaW5lciBpbiBJTlJcclxuXHJcbiAgICAvLyBQb3J0IGNoYXJnZXNcclxuICAgIHBvcnRIYW5kbGluZ1BlckNvbnRhaW5lcixcclxuICAgIGNoYUNoYXJnZXMsXHJcbiAgICBjdXN0b21zQ2xlYXJhbmNlLFxyXG5cclxuICAgIC8vIENvc3QgaGVhZHNcclxuICAgIGNvc3RIZWFkcyA9IFtdLFxyXG5cclxuICAgIC8vIENlcnRpZmljYXRpb25zXHJcbiAgICBjZXJ0aWZpY2F0aW9ucyA9IFtdLFxyXG5cclxuICAgIC8vIEludGVybmF0aW9uYWwgRnJlaWdodFxyXG4gICAgZnJlaWdodFJhdGUsICAvLyBQZXIgY29udGFpbmVyIGluIGZvcmVpZ24gY3VycmVuY3lcclxuICAgIGZyZWlnaHRDdXJyZW5jeSA9ICdVU0QnLFxyXG4gICAgZnJlaWdodENvbnZlcnNpb25SYXRlID0gMS4wLFxyXG4gICAgZnJlaWdodEdTVCA9IDUsXHJcblxyXG4gICAgLy8gQ3VycmVuY3kgc2V0dGluZ3NcclxuICAgIGV4Y2hhbmdlUmF0ZSA9IDgzLjUwLFxyXG4gICAgYmFua01hcmdpbiA9IDAuNTAsXHJcblxyXG4gICAgLy8gRUNHQ1xyXG4gICAgZWNnY1JhdGUgPSAwLjUwLFxyXG5cclxuICAgIC8vIEluc3VyYW5jZVxyXG4gICAgaW5zdXJhbmNlUmF0ZSA9IDAuNTAsXHJcbiAgICBtaW5JbnN1cmFuY2UgPSA1MDAwLFxyXG5cclxuICAgIC8vIEJhbmsgY2hhcmdlc1xyXG4gICAgYmFua0NoYXJnZVJhdGUgPSAwLjI1LFxyXG5cclxuICAgIC8vIFByb2ZpdFxyXG4gICAgcHJvZml0UmF0ZSA9IDUuMCxcclxuICAgIHByb2ZpdFR5cGUgPSAncGVyY2VudGFnZScsXHJcblxyXG4gICAgLy8gRGlzcGxheSBjdXJyZW5jeVxyXG4gICAgZGlzcGxheUN1cnJlbmN5ID0gJ1VTRCcsXHJcblxyXG4gICAgLy8gU2VsZWN0ZWQgcHJpY2luZyB0aWVyOiAnZXhGYWN0b3J5JywgJ2ZvYicsIG9yICdjaWYnXHJcbiAgICAvLyBQcm9maXQgd2lsbCBiZSBjYWxjdWxhdGVkIGF0IHRoZSBzZWxlY3RlZCB0aWVyXHJcbiAgICBzZWxlY3RlZFRpZXIgPSAnY2lmJyxcclxuXHJcbiAgICAvLyBDdXN0b20gY2hhcmdlcyAoaW4gSU5SKVxyXG4gICAgcGFja2FnaW5nQ2hhcmdlcyA9IDAsXHJcbiAgICBleHRyYUNoYXJnZXMgPSAwXHJcbn0pIHtcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gU1RFUCAxOiBDT05UQUlORVIgQ0FMQ1VMQVRJT05cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBjb25zdCBjb250YWluZXJDb3VudCA9IGNhbGN1bGF0ZUNvbnRhaW5lcnMocXVhbnRpdHksIHF0eVBlckNvbnRhaW5lcik7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgMjogUEFDS0FHSU5HIENIQVJHRVMgKHBlciBib3gsIGFkZGVkIHRvIHByb2R1Y3QgY29zdClcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBjb25zdCB0b3RhbFBhY2thZ2luZ0NoYXJnZXMgPSBwYXJzZUZsb2F0KHBhY2thZ2luZ0NoYXJnZXMpIHx8IDA7XHJcbiAgICBjb25zdCB0b3RhbEV4dHJhQ2hhcmdlc0Ftb3VudCA9IHBhcnNlRmxvYXQoZXh0cmFDaGFyZ2VzKSB8fCAwO1xyXG4gICAgY29uc3QgY3VzdG9tQ2hhcmdlc1RvdGFsID0gdG90YWxQYWNrYWdpbmdDaGFyZ2VzICsgdG90YWxFeHRyYUNoYXJnZXNBbW91bnQ7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgMzogRVgtRkFDVE9SWSBDT1NUIChQcm9kdWN0ICsgUGFja2FnaW5nKVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IGJhc2VQcmljZSA9IHBhcnNlRmxvYXQocHJvZHVjdC5iYXNlX3ByaWNlX3VzZCkgfHwgMDtcclxuICAgIGNvbnN0IGV4RmFjdG9yeVByb2R1Y3RVU0QgPSBiYXNlUHJpY2UgKiBxdWFudGl0eTtcclxuICAgIGNvbnN0IGV4RmFjdG9yeVByb2R1Y3RJTlIgPSBjb252ZXJ0VG9JTlIoZXhGYWN0b3J5UHJvZHVjdFVTRCwgZXhjaGFuZ2VSYXRlLCAwKTtcclxuICAgIC8vIEFkZCBwYWNrYWdpbmcgYW5kIGV4dHJhIGNoYXJnZXMgdG8gRXgtRmFjdG9yeVxyXG4gICAgY29uc3QgZXhGYWN0b3J5SU5SID0gZXhGYWN0b3J5UHJvZHVjdElOUiArIGN1c3RvbUNoYXJnZXNUb3RhbDtcclxuICAgIGNvbnN0IGV4RmFjdG9yeVVTRCA9IGNvbnZlcnRUb1VTRChleEZhY3RvcnlJTlIsIGV4Y2hhbmdlUmF0ZSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgMzogTE9DQUwgRlJFSUdIVCAoUGVyIENvbnRhaW5lcilcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBjb25zdCBsb2NhbEZyZWlnaHRQZXJDb250YWluZXIgPSBwYXJzZUZsb2F0KGxvY2FsRnJlaWdodFJhdGUpIHx8IDA7XHJcbiAgICBjb25zdCBsb2NhbEZyZWlnaHRUb3RhbCA9IGxvY2FsRnJlaWdodFBlckNvbnRhaW5lciAqIGNvbnRhaW5lckNvdW50O1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBTVEVQIDQ6IEhBTkRMSU5HICYgTEFCT1VSIChGcm9tIENvc3QgSGVhZHMpXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgY29uc3QgaGFuZGxpbmdDb3N0cyA9IGNhbGN1bGF0ZUNvc3RIZWFkcyhcclxuICAgICAgICBjb3N0SGVhZHMuZmlsdGVyKGMgPT4gYy5jYXRlZ29yeSA9PT0gJ2hhbmRsaW5nJyksXHJcbiAgICAgICAgY29udGFpbmVyQ291bnQsXHJcbiAgICAgICAgcXVhbnRpdHksXHJcbiAgICAgICAgZXhGYWN0b3J5SU5SXHJcbiAgICApO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBTVEVQIDU6IFBPUlQgQ0hBUkdFU1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IHBvcnRIYW5kbGluZ1RvdGFsID0gKHBhcnNlRmxvYXQocG9ydEhhbmRsaW5nUGVyQ29udGFpbmVyKSB8fCAwKSAqIGNvbnRhaW5lckNvdW50O1xyXG4gICAgY29uc3QgY2hhVG90YWwgPSBwYXJzZUZsb2F0KGNoYUNoYXJnZXMpIHx8IDA7ICAvLyBQZXIgc2hpcG1lbnRcclxuICAgIGNvbnN0IGN1c3RvbXNUb3RhbCA9IHBhcnNlRmxvYXQoY3VzdG9tc0NsZWFyYW5jZSkgfHwgMDsgIC8vIFBlciBzaGlwbWVudFxyXG5cclxuICAgIGNvbnN0IHBvcnRDb3N0cyA9IHtcclxuICAgICAgICBoYW5kbGluZzogcG9ydEhhbmRsaW5nVG90YWwsXHJcbiAgICAgICAgY2hhOiBjaGFUb3RhbCxcclxuICAgICAgICBjdXN0b21zOiBjdXN0b21zVG90YWwsXHJcbiAgICAgICAgdG90YWw6IHBvcnRIYW5kbGluZ1RvdGFsICsgY2hhVG90YWwgKyBjdXN0b21zVG90YWxcclxuICAgIH07XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgNjogTUlTQ0VMTEFORU9VUyBDSEFSR0VTXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgY29uc3QgbWlzY0Nvc3RzID0gY2FsY3VsYXRlQ29zdEhlYWRzKFxyXG4gICAgICAgIGNvc3RIZWFkcy5maWx0ZXIoYyA9PiBjLmNhdGVnb3J5ID09PSAnbWlzYycpLFxyXG4gICAgICAgIGNvbnRhaW5lckNvdW50LFxyXG4gICAgICAgIHF1YW50aXR5LFxyXG4gICAgICAgIGV4RmFjdG9yeUlOUlxyXG4gICAgKTtcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gU1RFUCA3OiBDRVJUSUZJQ0FUSU9OU1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGxldCBjZXJ0aWZpY2F0aW9uVG90YWwgPSAwO1xyXG4gICAgY29uc3QgY2VydEJyZWFrZG93biA9IFtdO1xyXG5cclxuICAgIGNlcnRpZmljYXRpb25zLmZvckVhY2goY2VydCA9PiB7XHJcbiAgICAgICAgbGV0IGNvc3QgPSAwO1xyXG4gICAgICAgIGlmIChjZXJ0LmNvc3RfcGVyY2VudGFnZSA+IDApIHtcclxuICAgICAgICAgICAgY29zdCA9IGV4RmFjdG9yeUlOUiAqIChjZXJ0LmNvc3RfcGVyY2VudGFnZSAvIDEwMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29zdCA9IHBhcnNlRmxvYXQoY2VydC5jb3N0X2ZsYXQpIHx8IDA7XHJcbiAgICAgICAgICAgIGlmIChjZXJ0LmNoYXJnZV90eXBlID09PSAncGVyX2NvbnRhaW5lcicpIHtcclxuICAgICAgICAgICAgICAgIGNvc3QgPSBjb3N0ICogY29udGFpbmVyQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2VydGlmaWNhdGlvblRvdGFsICs9IGNvc3Q7XHJcbiAgICAgICAgaWYgKGNvc3QgPiAwKSB7XHJcbiAgICAgICAgICAgIGNlcnRCcmVha2Rvd24ucHVzaCh7IG5hbWU6IGNlcnQubmFtZSwgY29zdDogcm91bmRUb1R3byhjb3N0KSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gU1RFUCA4OiBGT0IgQ0FMQ1VMQVRJT05cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBOb3RlOiBQYWNrYWdpbmcgYW5kIGV4dHJhIGNoYXJnZXMgYXJlIGFscmVhZHkgaW5jbHVkZWQgaW4gZXhGYWN0b3J5SU5SXHJcbiAgICBjb25zdCBmb2JJTlIgPSBleEZhY3RvcnlJTlJcclxuICAgICAgICArIGxvY2FsRnJlaWdodFRvdGFsXHJcbiAgICAgICAgKyBoYW5kbGluZ0Nvc3RzLnRvdGFsXHJcbiAgICAgICAgKyBwb3J0Q29zdHMudG90YWxcclxuICAgICAgICArIG1pc2NDb3N0cy50b3RhbFxyXG4gICAgICAgICsgY2VydGlmaWNhdGlvblRvdGFsO1xyXG5cclxuICAgIGNvbnN0IGZvYlVTRCA9IGNvbnZlcnRUb1VTRChmb2JJTlIsIGV4Y2hhbmdlUmF0ZSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgOTogRUNHQyAoRXhwb3J0IENyZWRpdCBHdWFyYW50ZWUpXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgY29uc3QgZWNnY0Ftb3VudCA9IGZvYklOUiAqIChlY2djUmF0ZSAvIDEwMCk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgMTA6IElOVEVSTkFUSU9OQUwgRlJFSUdIVFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IGZyZWlnaHRQZXJDb250YWluZXIgPSBwYXJzZUZsb2F0KGZyZWlnaHRSYXRlKSB8fCAwO1xyXG4gICAgY29uc3QgZnJlaWdodFRvdGFsRm9yZWlnbiA9IGZyZWlnaHRQZXJDb250YWluZXIgKiBjb250YWluZXJDb3VudDtcclxuXHJcbiAgICAvLyBBcHBseSBmcmVpZ2h0IGNvbnZlcnNpb24gcmF0ZVxyXG4gICAgY29uc3QgZnJlaWdodEFkanVzdGVkID0gZnJlaWdodFRvdGFsRm9yZWlnbiAqIChwYXJzZUZsb2F0KGZyZWlnaHRDb252ZXJzaW9uUmF0ZSkgfHwgMSk7XHJcblxyXG4gICAgLy8gQ29udmVydCB0byBJTlIgd2l0aCBiYW5rIG1hcmdpblxyXG4gICAgY29uc3QgZnJlaWdodElOUiA9IGNvbnZlcnRUb0lOUihmcmVpZ2h0QWRqdXN0ZWQsIGV4Y2hhbmdlUmF0ZSwgYmFua01hcmdpbik7XHJcblxyXG4gICAgLy8gQWRkIEdTVCBvbiBmcmVpZ2h0XHJcbiAgICBjb25zdCBmcmVpZ2h0R1NUQW1vdW50ID0gZnJlaWdodElOUiAqIChmcmVpZ2h0R1NUIC8gMTAwKTtcclxuICAgIGNvbnN0IGZyZWlnaHRXaXRoR1NUID0gZnJlaWdodElOUiArIGZyZWlnaHRHU1RBbW91bnQ7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgMTE6IElOU1VSQU5DRVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIEluc3VyYW5jZSBpcyBjYWxjdWxhdGVkIG9uIENJRiwgc28gd2UgbmVlZCBpdGVyYXRpdmUgY2FsY3VsYXRpb25cclxuICAgIC8vIENJRiA9IEZPQiArIEZyZWlnaHQgKyBJbnN1cmFuY2VcclxuICAgIC8vIEluc3VyYW5jZSA9IEluc3VyYW5jZVJhdGUlIMOXIENJRlxyXG4gICAgLy8gU286IEluc3VyYW5jZSA9IEluc3VyYW5jZVJhdGUlIMOXIChGT0IgKyBGcmVpZ2h0ICsgSW5zdXJhbmNlKVxyXG4gICAgLy8gSW5zdXJhbmNlIMOXICgxIC0gSW5zdXJhbmNlUmF0ZSUpID0gSW5zdXJhbmNlUmF0ZSUgw5cgKEZPQiArIEZyZWlnaHQpXHJcbiAgICAvLyBJbnN1cmFuY2UgPSAoSW5zdXJhbmNlUmF0ZSUgw5cgKEZPQiArIEZyZWlnaHQpKSAvICgxIC0gSW5zdXJhbmNlUmF0ZSUpXHJcblxyXG4gICAgY29uc3QgcHJlQ2lmQmFzZSA9IGZvYklOUiArIGVjZ2NBbW91bnQgKyBmcmVpZ2h0V2l0aEdTVDtcclxuICAgIGxldCBpbnN1cmFuY2VBbW91bnQgPSAocHJlQ2lmQmFzZSAqIChpbnN1cmFuY2VSYXRlIC8gMTAwKSkgLyAoMSAtIChpbnN1cmFuY2VSYXRlIC8gMTAwKSk7XHJcblxyXG4gICAgaWYgKGluc3VyYW5jZUFtb3VudCA8IG1pbkluc3VyYW5jZSkge1xyXG4gICAgICAgIGluc3VyYW5jZUFtb3VudCA9IG1pbkluc3VyYW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gU1RFUCAxMjogQkFOSyBDSEFSR0VTXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgY29uc3QgaW52b2ljZVZhbHVlID0gcHJlQ2lmQmFzZSArIGluc3VyYW5jZUFtb3VudDtcclxuICAgIGNvbnN0IGJhbmtDaGFyZ2VzID0gaW52b2ljZVZhbHVlICogKGJhbmtDaGFyZ2VSYXRlIC8gMTAwKTtcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gU1RFUCAxMzogUFJPRklUIE1BUkdJTiAoQXBwbGllZCBhdCBzZWxlY3RlZCB0aWVyKVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IGNvc3RCYXNlQ0lGID0gaW52b2ljZVZhbHVlICsgYmFua0NoYXJnZXM7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHByb2ZpdCBiYXNlIGJhc2VkIG9uIHNlbGVjdGVkIHRpZXJcclxuICAgIGxldCBwcm9maXRCYXNlID0gMDtcclxuICAgIGlmIChzZWxlY3RlZFRpZXIgPT09ICdleEZhY3RvcnknKSB7XHJcbiAgICAgICAgcHJvZml0QmFzZSA9IGV4RmFjdG9yeUlOUjtcclxuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRUaWVyID09PSAnZm9iJykge1xyXG4gICAgICAgIHByb2ZpdEJhc2UgPSBmb2JJTlI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENJRiAtIHVzZSBmdWxsIGNvc3QgYmFzZVxyXG4gICAgICAgIHByb2ZpdEJhc2UgPSBjb3N0QmFzZUNJRjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcHJvZml0QW1vdW50ID0gMDtcclxuICAgIGlmIChwcm9maXRUeXBlID09PSAncGVyY2VudGFnZScpIHtcclxuICAgICAgICBwcm9maXRBbW91bnQgPSBwcm9maXRCYXNlICogKHByb2ZpdFJhdGUgLyAxMDApO1xyXG4gICAgfSBlbHNlIGlmIChwcm9maXRUeXBlID09PSAncGVyX2NvbnRhaW5lcicpIHtcclxuICAgICAgICBwcm9maXRBbW91bnQgPSBwcm9maXRSYXRlICogY29udGFpbmVyQ291bnQ7XHJcbiAgICB9IGVsc2UgaWYgKHByb2ZpdFR5cGUgPT09ICdwZXJfdW5pdCcpIHtcclxuICAgICAgICBwcm9maXRBbW91bnQgPSBwcm9maXRSYXRlICogcXVhbnRpdHk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByb2ZpdEFtb3VudCA9IHByb2ZpdFJhdGU7ICAvLyBGaXhlZCBhbW91bnRcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gU1RFUCAxNDogRklOQUwgUFJJQ0VTIFdJVEggUFJPRklUIEFUIFNFTEVDVEVEIFRJRVJcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGZpbmFsIHByaWNlcyBiYXNlZCBvbiBzZWxlY3RlZCB0aWVyXHJcbiAgICBsZXQgZXhGYWN0b3J5RmluYWxJTlIgPSBleEZhY3RvcnlJTlI7XHJcbiAgICBsZXQgZm9iRmluYWxJTlIgPSBmb2JJTlI7XHJcbiAgICBsZXQgY2lmRmluYWxJTlIgPSBjb3N0QmFzZUNJRjtcclxuXHJcbiAgICBpZiAoc2VsZWN0ZWRUaWVyID09PSAnZXhGYWN0b3J5Jykge1xyXG4gICAgICAgIC8vIFByb2ZpdCBhZGRlZCB0byBFeCBGYWN0b3J5IG9ubHlcclxuICAgICAgICBleEZhY3RvcnlGaW5hbElOUiA9IGV4RmFjdG9yeUlOUiArIHByb2ZpdEFtb3VudDtcclxuICAgICAgICBmb2JGaW5hbElOUiA9IGZvYklOUjsgLy8gTm8gcHJvZml0IGluIEZPQi9DSUZcclxuICAgICAgICBjaWZGaW5hbElOUiA9IGNvc3RCYXNlQ0lGO1xyXG4gICAgfSBlbHNlIGlmIChzZWxlY3RlZFRpZXIgPT09ICdmb2InKSB7XHJcbiAgICAgICAgLy8gUHJvZml0IGFkZGVkIHRvIEZPQlxyXG4gICAgICAgIGV4RmFjdG9yeUZpbmFsSU5SID0gZXhGYWN0b3J5SU5SO1xyXG4gICAgICAgIGZvYkZpbmFsSU5SID0gZm9iSU5SICsgcHJvZml0QW1vdW50O1xyXG4gICAgICAgIGNpZkZpbmFsSU5SID0gY29zdEJhc2VDSUY7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENJRiAtIHByb2ZpdCBhZGRlZCB0byBmdWxsIGNvc3QgKGN1cnJlbnQgYmVoYXZpb3IpXHJcbiAgICAgICAgZXhGYWN0b3J5RmluYWxJTlIgPSBleEZhY3RvcnlJTlI7XHJcbiAgICAgICAgZm9iRmluYWxJTlIgPSBmb2JJTlI7XHJcbiAgICAgICAgY2lmRmluYWxJTlIgPSBjb3N0QmFzZUNJRiArIHByb2ZpdEFtb3VudDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBleEZhY3RvcnlGaW5hbFVTRCA9IGNvbnZlcnRUb1VTRChleEZhY3RvcnlGaW5hbElOUiwgZXhjaGFuZ2VSYXRlKTtcclxuICAgIGNvbnN0IGZvYkZpbmFsVVNEID0gY29udmVydFRvVVNEKGZvYkZpbmFsSU5SLCBleGNoYW5nZVJhdGUpO1xyXG4gICAgY29uc3QgY2lmRmluYWxVU0QgPSBjb252ZXJ0VG9VU0QoY2lmRmluYWxJTlIsIGV4Y2hhbmdlUmF0ZSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFJFVFVSTiBDT01QTEVURSBCUkVBS0RPV05cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC8vIENvbnRhaW5lciBpbmZvXHJcbiAgICAgICAgY29udGFpbmVyVHlwZTogY29udGFpbmVyVHlwZT8ubmFtZSB8fCAnTi9BJyxcclxuICAgICAgICBjb250YWluZXJDb2RlOiBjb250YWluZXJUeXBlPy5jb2RlIHx8ICdOL0EnLFxyXG4gICAgICAgIHF0eVBlckNvbnRhaW5lcixcclxuICAgICAgICBjb250YWluZXJDb3VudCxcclxuXHJcbiAgICAgICAgLy8gU2VsZWN0ZWQgcHJpY2luZyB0aWVyIGluZm9cclxuICAgICAgICBzZWxlY3RlZFRpZXIsXHJcbiAgICAgICAgdGllckxhYmVsczoge1xyXG4gICAgICAgICAgICBleEZhY3Rvcnk6ICdFeCBGYWN0b3J5JyxcclxuICAgICAgICAgICAgZm9iOiAnRk9CIChGcmVlIG9uIEJvYXJkKScsXHJcbiAgICAgICAgICAgIGNpZjogJ0NJRiAoQ29zdCBJbnN1cmFuY2UgRnJlaWdodCknXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gTWFpbiBwcmljZXMgKHdpdGggcHJvZml0IGFwcGxpZWQgYXQgc2VsZWN0ZWQgdGllcilcclxuICAgICAgICBleEZhY3Rvcnk6IHtcclxuICAgICAgICAgICAgaW5yOiByb3VuZFRvVHdvKGV4RmFjdG9yeUZpbmFsSU5SKSxcclxuICAgICAgICAgICAgdXNkOiByb3VuZFRvVHdvKGV4RmFjdG9yeUZpbmFsVVNEKSxcclxuICAgICAgICAgICAgYmFzZUlucjogcm91bmRUb1R3byhleEZhY3RvcnlJTlIpLFxyXG4gICAgICAgICAgICBiYXNlVXNkOiByb3VuZFRvVHdvKGV4RmFjdG9yeVVTRClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvYjoge1xyXG4gICAgICAgICAgICBpbnI6IHJvdW5kVG9Ud28oZm9iRmluYWxJTlIpLFxyXG4gICAgICAgICAgICB1c2Q6IHJvdW5kVG9Ud28oZm9iRmluYWxVU0QpLFxyXG4gICAgICAgICAgICBiYXNlSW5yOiByb3VuZFRvVHdvKGZvYklOUiksXHJcbiAgICAgICAgICAgIGJhc2VVc2Q6IHJvdW5kVG9Ud28oZm9iVVNEKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2lmOiB7XHJcbiAgICAgICAgICAgIGlucjogcm91bmRUb1R3byhjaWZGaW5hbElOUiksXHJcbiAgICAgICAgICAgIHVzZDogcm91bmRUb1R3byhjaWZGaW5hbFVTRCksXHJcbiAgICAgICAgICAgIGJhc2VJbnI6IHJvdW5kVG9Ud28oY29zdEJhc2VDSUYpLFxyXG4gICAgICAgICAgICBiYXNlVXNkOiByb3VuZFRvVHdvKGNvbnZlcnRUb1VTRChjb3N0QmFzZUNJRiwgZXhjaGFuZ2VSYXRlKSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBQZXIgdW5pdCBwcmljZXMgKHVzaW5nIGZpbmFsIHByaWNlcyB3aXRoIHByb2ZpdClcclxuICAgICAgICBwZXJVbml0OiB7XHJcbiAgICAgICAgICAgIGV4RmFjdG9yeTogcm91bmRUb1R3byhleEZhY3RvcnlGaW5hbFVTRCAvIHF1YW50aXR5KSxcclxuICAgICAgICAgICAgZm9iOiByb3VuZFRvVHdvKGZvYkZpbmFsVVNEIC8gcXVhbnRpdHkpLFxyXG4gICAgICAgICAgICBjaWY6IHJvdW5kVG9Ud28oY2lmRmluYWxVU0QgLyBxdWFudGl0eSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBEZXRhaWxlZCBicmVha2Rvd25cclxuICAgICAgICBicmVha2Rvd246IHtcclxuICAgICAgICAgICAgcHJvZHVjdEJhc2U6IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnUHJvZHVjdCBCYXNlIFByaWNlJyxcclxuICAgICAgICAgICAgICAgIHBlclVuaXQ6IGJhc2VQcmljZSxcclxuICAgICAgICAgICAgICAgIHF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IHJvdW5kVG9Ud28oZXhGYWN0b3J5UHJvZHVjdElOUiksXHJcbiAgICAgICAgICAgICAgICBjaGFyZ2VUeXBlOiAncGVyX3VuaXQnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhY2thZ2luZ0NoYXJnZXM6IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnUGFja2FnaW5nICYgRXh0cmEgQ2hhcmdlcycsXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogcm91bmRUb1R3byhjdXN0b21DaGFyZ2VzVG90YWwpLFxyXG4gICAgICAgICAgICAgICAgY2hhcmdlVHlwZTogJ2ZsYXQnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxvY2FsRnJlaWdodDoge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdMb2NhbCBGcmVpZ2h0JyxcclxuICAgICAgICAgICAgICAgIHBlckNvbnRhaW5lcjogbG9jYWxGcmVpZ2h0UGVyQ29udGFpbmVyLFxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyczogY29udGFpbmVyQ291bnQsXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogcm91bmRUb1R3byhsb2NhbEZyZWlnaHRUb3RhbCksXHJcbiAgICAgICAgICAgICAgICBjaGFyZ2VUeXBlOiAncGVyX2NvbnRhaW5lcidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFuZGxpbmc6IGhhbmRsaW5nQ29zdHMsXHJcbiAgICAgICAgICAgIHBvcnQ6IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnUG9ydCBDaGFyZ2VzJyxcclxuICAgICAgICAgICAgICAgIGhhbmRsaW5nOiByb3VuZFRvVHdvKHBvcnRIYW5kbGluZ1RvdGFsKSxcclxuICAgICAgICAgICAgICAgIGNoYTogcm91bmRUb1R3byhjaGFUb3RhbCksXHJcbiAgICAgICAgICAgICAgICBjdXN0b21zOiByb3VuZFRvVHdvKGN1c3RvbXNUb3RhbCksXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogcm91bmRUb1R3byhwb3J0Q29zdHMudG90YWwpLFxyXG4gICAgICAgICAgICAgICAgY2hhcmdlVHlwZTogJ21peGVkJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtaXNjOiBtaXNjQ29zdHMsXHJcbiAgICAgICAgICAgIGNlcnRpZmljYXRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBpdGVtczogY2VydEJyZWFrZG93bixcclxuICAgICAgICAgICAgICAgIHRvdGFsOiByb3VuZFRvVHdvKGNlcnRpZmljYXRpb25Ub3RhbClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZWNnYzoge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdFQ0dDIFByZW1pdW0nLFxyXG4gICAgICAgICAgICAgICAgcmF0ZTogZWNnY1JhdGUsXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogcm91bmRUb1R3byhlY2djQW1vdW50KSxcclxuICAgICAgICAgICAgICAgIGNoYXJnZVR5cGU6ICdwZXJjZW50YWdlJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmcmVpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0ludGVybmF0aW9uYWwgRnJlaWdodCcsXHJcbiAgICAgICAgICAgICAgICBwZXJDb250YWluZXI6IGZyZWlnaHRQZXJDb250YWluZXIsXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJzOiBjb250YWluZXJDb3VudCxcclxuICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBmcmVpZ2h0Q3VycmVuY3ksXHJcbiAgICAgICAgICAgICAgICBmb3JlaWduVG90YWw6IHJvdW5kVG9Ud28oZnJlaWdodFRvdGFsRm9yZWlnbiksXHJcbiAgICAgICAgICAgICAgICBjb252ZXJzaW9uUmF0ZTogZnJlaWdodENvbnZlcnNpb25SYXRlLFxyXG4gICAgICAgICAgICAgICAgZXhjaGFuZ2VSYXRlOiBleGNoYW5nZVJhdGUgKyBiYW5rTWFyZ2luLFxyXG4gICAgICAgICAgICAgICAgaW5yVG90YWw6IHJvdW5kVG9Ud28oZnJlaWdodElOUiksXHJcbiAgICAgICAgICAgICAgICBnc3RSYXRlOiBmcmVpZ2h0R1NULFxyXG4gICAgICAgICAgICAgICAgZ3N0QW1vdW50OiByb3VuZFRvVHdvKGZyZWlnaHRHU1RBbW91bnQpLFxyXG4gICAgICAgICAgICAgICAgdG90YWxXaXRoR1NUOiByb3VuZFRvVHdvKGZyZWlnaHRXaXRoR1NUKSxcclxuICAgICAgICAgICAgICAgIGNoYXJnZVR5cGU6ICdwZXJfY29udGFpbmVyJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnN1cmFuY2U6IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnTWFyaW5lIEluc3VyYW5jZScsXHJcbiAgICAgICAgICAgICAgICByYXRlOiBpbnN1cmFuY2VSYXRlLFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IHJvdW5kVG9Ud28oaW5zdXJhbmNlQW1vdW50KSxcclxuICAgICAgICAgICAgICAgIGNoYXJnZVR5cGU6ICdwZXJjZW50YWdlJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBiYW5rQ2hhcmdlczoge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdCYW5rIENoYXJnZXMnLFxyXG4gICAgICAgICAgICAgICAgcmF0ZTogYmFua0NoYXJnZVJhdGUsXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogcm91bmRUb1R3byhiYW5rQ2hhcmdlcyksXHJcbiAgICAgICAgICAgICAgICBjaGFyZ2VUeXBlOiAncGVyY2VudGFnZSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvZml0OiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0NvbXBhbnkgTWFyZ2luJyxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHByb2ZpdFR5cGUsXHJcbiAgICAgICAgICAgICAgICByYXRlOiBwcm9maXRSYXRlLFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IHJvdW5kVG9Ud28ocHJvZml0QW1vdW50KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gU3VtbWFyeSBieSBjaGFyZ2UgdHlwZVxyXG4gICAgICAgIHN1bW1hcnk6IHtcclxuICAgICAgICAgICAgcGVyU2hpcG1lbnRDb3N0czogcm91bmRUb1R3byhcclxuICAgICAgICAgICAgICAgIGhhbmRsaW5nQ29zdHMucGVyU2hpcG1lbnQgK1xyXG4gICAgICAgICAgICAgICAgY2hhVG90YWwgK1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tc1RvdGFsICtcclxuICAgICAgICAgICAgICAgIG1pc2NDb3N0cy5wZXJTaGlwbWVudCArXHJcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0aW9uVG90YWwgK1xyXG4gICAgICAgICAgICAgICAgZWNnY0Ftb3VudCArXHJcbiAgICAgICAgICAgICAgICBpbnN1cmFuY2VBbW91bnQgK1xyXG4gICAgICAgICAgICAgICAgYmFua0NoYXJnZXMgK1xyXG4gICAgICAgICAgICAgICAgcHJvZml0QW1vdW50XHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIHBlckNvbnRhaW5lckNvc3RzOiByb3VuZFRvVHdvKFxyXG4gICAgICAgICAgICAgICAgbG9jYWxGcmVpZ2h0VG90YWwgK1xyXG4gICAgICAgICAgICAgICAgaGFuZGxpbmdDb3N0cy5wZXJDb250YWluZXIgK1xyXG4gICAgICAgICAgICAgICAgcG9ydEhhbmRsaW5nVG90YWwgK1xyXG4gICAgICAgICAgICAgICAgbWlzY0Nvc3RzLnBlckNvbnRhaW5lciArXHJcbiAgICAgICAgICAgICAgICBmcmVpZ2h0V2l0aEdTVFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gQ3VycmVuY3kgaW5mb1xyXG4gICAgICAgIGN1cnJlbmN5OiB7XHJcbiAgICAgICAgICAgIGV4Y2hhbmdlOiBleGNoYW5nZVJhdGUsXHJcbiAgICAgICAgICAgIGJhbmtNYXJnaW4sXHJcbiAgICAgICAgICAgIGVmZmVjdGl2ZTogZXhjaGFuZ2VSYXRlICsgYmFua01hcmdpblxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFVUSUxJVFkgRlVOQ1RJT05TXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4vKipcclxuICogUm91bmQgdG8gMiBkZWNpbWFsIHBsYWNlc1xyXG4gKi9cclxuZnVuY3Rpb24gcm91bmRUb1R3byh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKHZhbHVlIHx8IDApICogMTAwKSAvIDEwMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBjdXJyZW5jeSAoSU5SKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdElOUihhbW91bnQpIHtcclxuICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoJ2VuLUlOJywge1xyXG4gICAgICAgIHN0eWxlOiAnY3VycmVuY3knLFxyXG4gICAgICAgIGN1cnJlbmN5OiAnSU5SJyxcclxuICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXHJcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyXHJcbiAgICB9KS5mb3JtYXQoYW1vdW50IHx8IDApO1xyXG59XHJcblxyXG4vKipcclxuICogRm9ybWF0IGN1cnJlbmN5IChVU0QpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VVNEKGFtb3VudCkge1xyXG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tVVMnLCB7XHJcbiAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXHJcbiAgICAgICAgY3VycmVuY3k6ICdVU0QnLFxyXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcclxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDJcclxuICAgIH0pLmZvcm1hdChhbW91bnQgfHwgMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgbnVtYmVyIHdpdGggY29tbWFzIChJbmRpYW4gc3R5bGUpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSkge1xyXG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tSU4nKS5mb3JtYXQobnVtIHx8IDApO1xyXG59XHJcblxyXG4vKipcclxuICogRm9ybWF0IGFzIHBlcmNlbnRhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRQZXJjZW50KHJhdGUpIHtcclxuICAgIHJldHVybiBgJHtyYXRlfSVgO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVDb250YWluZXJzIiwicXVhbnRpdHkiLCJxdHlQZXJDb250YWluZXIiLCJNYXRoIiwiY2VpbCIsImNvbnZlcnRUb0lOUiIsImFtb3VudCIsImV4Y2hhbmdlUmF0ZSIsImJhbmtNYXJnaW4iLCJlZmZlY3RpdmVSYXRlIiwiY29udmVydFRvVVNEIiwiYW1vdW50SU5SIiwidXNkUmF0ZSIsImNhbGN1bGF0ZUNvc3RIZWFkcyIsImNvc3RIZWFkcyIsImNvbnRhaW5lckNvdW50IiwiYmFzZVZhbHVlIiwicGVyU2hpcG1lbnRUb3RhbCIsInBlckNvbnRhaW5lclRvdGFsIiwiYnJlYWtkb3duIiwiZm9yRWFjaCIsImNvc3QiLCJpc19hY3RpdmUiLCJkaXNwbGF5QW1vdW50IiwiY2FsY3VsYXRpb25fYmFzZSIsInBlcmNlbnRhZ2VfcmF0ZSIsInBhcnNlRmxvYXQiLCJiYXNlX2Ftb3VudCIsImNoYXJnZV90eXBlIiwicHVzaCIsIm5hbWUiLCJjaGFyZ2VUeXBlIiwidW5pdEFtb3VudCIsInRvdGFsIiwicGVyU2hpcG1lbnQiLCJyb3VuZFRvVHdvIiwicGVyQ29udGFpbmVyIiwiY2FsY3VsYXRlRXhwb3J0UHJpY2luZyIsInByb2R1Y3QiLCJjb250YWluZXJUeXBlIiwibG9jYWxGcmVpZ2h0UmF0ZSIsInBvcnRIYW5kbGluZ1BlckNvbnRhaW5lciIsImNoYUNoYXJnZXMiLCJjdXN0b21zQ2xlYXJhbmNlIiwiY2VydGlmaWNhdGlvbnMiLCJmcmVpZ2h0UmF0ZSIsImZyZWlnaHRDdXJyZW5jeSIsImZyZWlnaHRDb252ZXJzaW9uUmF0ZSIsImZyZWlnaHRHU1QiLCJlY2djUmF0ZSIsImluc3VyYW5jZVJhdGUiLCJtaW5JbnN1cmFuY2UiLCJiYW5rQ2hhcmdlUmF0ZSIsInByb2ZpdFJhdGUiLCJwcm9maXRUeXBlIiwiZGlzcGxheUN1cnJlbmN5Iiwic2VsZWN0ZWRUaWVyIiwicGFja2FnaW5nQ2hhcmdlcyIsImV4dHJhQ2hhcmdlcyIsInRvdGFsUGFja2FnaW5nQ2hhcmdlcyIsInRvdGFsRXh0cmFDaGFyZ2VzQW1vdW50IiwiY3VzdG9tQ2hhcmdlc1RvdGFsIiwiYmFzZVByaWNlIiwiYmFzZV9wcmljZV91c2QiLCJleEZhY3RvcnlQcm9kdWN0VVNEIiwiZXhGYWN0b3J5UHJvZHVjdElOUiIsImV4RmFjdG9yeUlOUiIsImV4RmFjdG9yeVVTRCIsImxvY2FsRnJlaWdodFBlckNvbnRhaW5lciIsImxvY2FsRnJlaWdodFRvdGFsIiwiaGFuZGxpbmdDb3N0cyIsImZpbHRlciIsImMiLCJjYXRlZ29yeSIsInBvcnRIYW5kbGluZ1RvdGFsIiwiY2hhVG90YWwiLCJjdXN0b21zVG90YWwiLCJwb3J0Q29zdHMiLCJoYW5kbGluZyIsImNoYSIsImN1c3RvbXMiLCJtaXNjQ29zdHMiLCJjZXJ0aWZpY2F0aW9uVG90YWwiLCJjZXJ0QnJlYWtkb3duIiwiY2VydCIsImNvc3RfcGVyY2VudGFnZSIsImNvc3RfZmxhdCIsImZvYklOUiIsImZvYlVTRCIsImVjZ2NBbW91bnQiLCJmcmVpZ2h0UGVyQ29udGFpbmVyIiwiZnJlaWdodFRvdGFsRm9yZWlnbiIsImZyZWlnaHRBZGp1c3RlZCIsImZyZWlnaHRJTlIiLCJmcmVpZ2h0R1NUQW1vdW50IiwiZnJlaWdodFdpdGhHU1QiLCJwcmVDaWZCYXNlIiwiaW5zdXJhbmNlQW1vdW50IiwiaW52b2ljZVZhbHVlIiwiYmFua0NoYXJnZXMiLCJjb3N0QmFzZUNJRiIsInByb2ZpdEJhc2UiLCJwcm9maXRBbW91bnQiLCJleEZhY3RvcnlGaW5hbElOUiIsImZvYkZpbmFsSU5SIiwiY2lmRmluYWxJTlIiLCJleEZhY3RvcnlGaW5hbFVTRCIsImZvYkZpbmFsVVNEIiwiY2lmRmluYWxVU0QiLCJjb250YWluZXJDb2RlIiwiY29kZSIsInRpZXJMYWJlbHMiLCJleEZhY3RvcnkiLCJmb2IiLCJjaWYiLCJpbnIiLCJ1c2QiLCJiYXNlSW5yIiwiYmFzZVVzZCIsInBlclVuaXQiLCJwcm9kdWN0QmFzZSIsImxhYmVsIiwibG9jYWxGcmVpZ2h0IiwiY29udGFpbmVycyIsInBvcnQiLCJtaXNjIiwiaXRlbXMiLCJlY2djIiwicmF0ZSIsImZyZWlnaHQiLCJjdXJyZW5jeSIsImZvcmVpZ25Ub3RhbCIsImNvbnZlcnNpb25SYXRlIiwiaW5yVG90YWwiLCJnc3RSYXRlIiwiZ3N0QW1vdW50IiwidG90YWxXaXRoR1NUIiwiaW5zdXJhbmNlIiwicHJvZml0IiwidHlwZSIsInN1bW1hcnkiLCJwZXJTaGlwbWVudENvc3RzIiwicGVyQ29udGFpbmVyQ29zdHMiLCJleGNoYW5nZSIsImVmZmVjdGl2ZSIsInZhbHVlIiwicm91bmQiLCJmb3JtYXRJTlIiLCJJbnRsIiwiTnVtYmVyRm9ybWF0Iiwic3R5bGUiLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJmb3JtYXQiLCJmb3JtYXRVU0QiLCJmb3JtYXROdW1iZXIiLCJudW0iLCJmb3JtYXRQZXJjZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/lib/calculator.js\n"));

/***/ })

});