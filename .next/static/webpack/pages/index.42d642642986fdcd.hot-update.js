"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/lib/calculator.js":
/*!*******************************!*\
  !*** ./src/lib/calculator.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateContainers: function() { return /* binding */ calculateContainers; },\n/* harmony export */   calculateCostHeads: function() { return /* binding */ calculateCostHeads; },\n/* harmony export */   calculateExportPricing: function() { return /* binding */ calculateExportPricing; },\n/* harmony export */   convertToINR: function() { return /* binding */ convertToINR; },\n/* harmony export */   convertToUSD: function() { return /* binding */ convertToUSD; },\n/* harmony export */   formatINR: function() { return /* binding */ formatINR; },\n/* harmony export */   formatNumber: function() { return /* binding */ formatNumber; },\n/* harmony export */   formatPercent: function() { return /* binding */ formatPercent; },\n/* harmony export */   formatUSD: function() { return /* binding */ formatUSD; }\n/* harmony export */ });\n/**\r\n * AROVAVE GLOBAL - Export Rate Calculator Engine v2\r\n * Container-Based FCL Export Pricing System\r\n * \r\n * Calculation Flow:\r\n * EX-FACTORY → Container Count → Local Freight → Handling → Port → FOB\r\n * → ECGC → Int'l Freight → Currency → Insurance → Bank → Profit → CIF\r\n */ // ============================================\n// CONTAINER CALCULATION\n// ============================================\n/**\r\n * Calculate number of containers required\r\n * @param {number} quantity - Total quantity ordered\r\n * @param {number} qtyPerContainer - How much fits in 1 container (user defined)\r\n * @returns {number} Number of containers needed\r\n */ function calculateContainers(quantity, qtyPerContainer) {\n    if (!quantity || !qtyPerContainer || qtyPerContainer <= 0) {\n        return 1;\n    }\n    return Math.ceil(quantity / qtyPerContainer);\n}\n// ============================================\n// CURRENCY CONVERSION\n// ============================================\n/**\r\n * Convert foreign currency to INR with bank margin\r\n * @param {number} amount - Amount in foreign currency\r\n * @param {number} exchangeRate - Base exchange rate to INR\r\n * @param {number} bankMargin - Bank's margin (e.g., 0.50)\r\n * @returns {number} Amount in INR\r\n */ function convertToINR(amount, exchangeRate) {\n    let bankMargin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    const effectiveRate = exchangeRate + bankMargin;\n    return amount * effectiveRate;\n}\n/**\r\n * Convert INR to USD for display\r\n * @param {number} amountINR\r\n * @param {number} usdRate\r\n * @returns {number}\r\n */ function convertToUSD(amountINR, usdRate) {\n    if (!usdRate || usdRate <= 0) return 0;\n    return amountINR / usdRate;\n}\n// ============================================\n// COST AGGREGATION\n// ============================================\n/**\r\n * Calculate costs based on charge type\r\n * @param {Array} costHeads - Array of cost head objects\r\n * @param {number} containerCount - Number of containers\r\n * @param {number} quantity - Total quantity\r\n * @param {number} baseValue - Base value for percentage calculations\r\n * @returns {Object} Categorized costs\r\n */ function calculateCostHeads(costHeads, containerCount, quantity) {\n    let baseValue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n    let perShipmentTotal = 0;\n    let perContainerTotal = 0;\n    const breakdown = [];\n    costHeads.forEach((cost)=>{\n        if (!cost.is_active) return;\n        let amount = 0;\n        let displayAmount = 0;\n        if (cost.calculation_base === \"percentage\") {\n            amount = baseValue * (cost.percentage_rate / 100);\n            displayAmount = amount;\n        } else {\n            amount = parseFloat(cost.base_amount) || 0;\n            if (cost.charge_type === \"per_container\") {\n                displayAmount = amount * containerCount;\n                perContainerTotal += displayAmount;\n            } else if (cost.charge_type === \"per_unit\") {\n                displayAmount = amount * quantity;\n                perShipmentTotal += displayAmount;\n            } else {\n                // per_shipment\n                displayAmount = amount;\n                perShipmentTotal += displayAmount;\n            }\n        }\n        if (displayAmount > 0) {\n            breakdown.push({\n                name: cost.name,\n                chargeType: cost.charge_type,\n                unitAmount: amount,\n                quantity: cost.charge_type === \"per_container\" ? containerCount : 1,\n                total: displayAmount\n            });\n        }\n    });\n    return {\n        perShipment: roundToTwo(perShipmentTotal),\n        perContainer: roundToTwo(perContainerTotal),\n        total: roundToTwo(perShipmentTotal + perContainerTotal),\n        breakdown\n    };\n}\n// ============================================\n// MAIN CALCULATION ENGINE\n// ============================================\n/**\r\n * Complete export pricing calculation\r\n * @param {Object} params - All input parameters\r\n * @returns {Object} Complete pricing breakdown\r\n */ function calculateExportPricing(param) {\n    let { // Product & Quantity\n    product, quantity, // Container\n    containerType, qtyPerContainer, // Locations\n    localFreightRate, // Port charges\n    portHandlingPerContainer, chaCharges, customsClearance, // Cost heads\n    costHeads = [], // Certifications\n    certifications = [], // International Freight\n    freightRate, freightCurrency = \"USD\", freightConversionRate = 1.0, freightGST = 5, // Currency settings\n    exchangeRate = 83.50, bankMargin = 0.50, // ECGC\n    ecgcRate = 0.50, // Insurance\n    insuranceRate = 0.50, minInsurance = 5000, // Bank charges\n    bankChargeRate = 0.25, // Profit\n    profitRate = 5.0, profitType = \"percentage\", // Display currency\n    displayCurrency = \"USD\", // Selected pricing tier: 'exFactory', 'fob', or 'cif'\n    // Profit will be calculated at the selected tier\n    selectedTier = \"cif\", // Custom charges (in INR)\n    packagingCharges = 0, extraCharges = 0 } = param;\n    // ============================================\n    // STEP 1: CONTAINER CALCULATION\n    // ============================================\n    const containerCount = calculateContainers(quantity, qtyPerContainer);\n    // ============================================\n    // STEP 2: PACKAGING CHARGES (per box, added to product cost)\n    // ============================================\n    const totalPackagingCharges = parseFloat(packagingCharges) || 0;\n    const totalExtraChargesAmount = parseFloat(extraCharges) || 0;\n    const customChargesTotal = totalPackagingCharges + totalExtraChargesAmount;\n    // ============================================\n    // STEP 3: EX-FACTORY COST (Product + Packaging)\n    // ============================================\n    const basePrice = parseFloat(product.base_price_usd) || 0;\n    const exFactoryProductUSD = basePrice * quantity;\n    const exFactoryProductINR = convertToINR(exFactoryProductUSD, exchangeRate, 0);\n    // Add packaging and extra charges to Ex-Factory\n    const exFactoryINR = exFactoryProductINR + customChargesTotal;\n    const exFactoryUSD = convertToUSD(exFactoryINR, exchangeRate);\n    // ============================================\n    // STEP 3: LOCAL FREIGHT (Per Container)\n    // ============================================\n    const localFreightPerContainer = parseFloat(localFreightRate) || 0;\n    const localFreightTotal = localFreightPerContainer * containerCount;\n    // ============================================\n    // STEP 4: HANDLING & LABOUR (From Cost Heads)\n    // ============================================\n    const handlingCosts = calculateCostHeads(costHeads.filter((c)=>c.category === \"handling\"), containerCount, quantity, exFactoryINR);\n    // ============================================\n    // STEP 5: PORT CHARGES\n    // ============================================\n    const portHandlingTotal = (parseFloat(portHandlingPerContainer) || 0) * containerCount;\n    const chaTotal = parseFloat(chaCharges) || 0; // Per shipment\n    const customsTotal = parseFloat(customsClearance) || 0; // Per shipment\n    const portCosts = {\n        handling: portHandlingTotal,\n        cha: chaTotal,\n        customs: customsTotal,\n        total: portHandlingTotal + chaTotal + customsTotal\n    };\n    // ============================================\n    // STEP 6: MISCELLANEOUS CHARGES\n    // ============================================\n    const miscCosts = calculateCostHeads(costHeads.filter((c)=>c.category === \"misc\"), containerCount, quantity, exFactoryINR);\n    // ============================================\n    // STEP 7: CERTIFICATIONS\n    // ============================================\n    let certificationTotal = 0;\n    const certBreakdown = [];\n    certifications.forEach((cert)=>{\n        let cost = 0;\n        if (cert.cost_percentage > 0) {\n            cost = exFactoryINR * (cert.cost_percentage / 100);\n        } else {\n            cost = parseFloat(cert.cost_flat) || 0;\n            if (cert.charge_type === \"per_container\") {\n                cost = cost * containerCount;\n            }\n        }\n        certificationTotal += cost;\n        if (cost > 0) {\n            certBreakdown.push({\n                name: cert.name,\n                cost: roundToTwo(cost)\n            });\n        }\n    });\n    // ============================================\n    // STEP 8: FOB CALCULATION\n    // ============================================\n    // Note: Packaging and extra charges are already included in exFactoryINR\n    const fobINR = exFactoryINR + localFreightTotal + handlingCosts.total + portCosts.total + miscCosts.total + certificationTotal;\n    const fobUSD = convertToUSD(fobINR, exchangeRate);\n    // ============================================\n    // STEP 9: ECGC (Export Credit Guarantee)\n    // ============================================\n    const ecgcAmount = fobINR * (ecgcRate / 100);\n    // ============================================\n    // STEP 10: INTERNATIONAL FREIGHT\n    // ============================================\n    const freightPerContainer = parseFloat(freightRate) || 0;\n    const freightTotalForeign = freightPerContainer * containerCount;\n    // Apply freight conversion rate\n    const freightAdjusted = freightTotalForeign * (parseFloat(freightConversionRate) || 1);\n    // Convert to INR with bank margin\n    const freightINR = convertToINR(freightAdjusted, exchangeRate, bankMargin);\n    // Add GST on freight\n    const freightGSTAmount = freightINR * (freightGST / 100);\n    const freightWithGST = freightINR + freightGSTAmount;\n    // ============================================\n    // STEP 11: INSURANCE\n    // ============================================\n    // Insurance is calculated on CIF, so we need iterative calculation\n    // CIF = FOB + Freight + Insurance\n    // Insurance = InsuranceRate% × CIF\n    // So: Insurance = InsuranceRate% × (FOB + Freight + Insurance)\n    // Insurance × (1 - InsuranceRate%) = InsuranceRate% × (FOB + Freight)\n    // Insurance = (InsuranceRate% × (FOB + Freight)) / (1 - InsuranceRate%)\n    const preCifBase = fobINR + ecgcAmount + freightWithGST;\n    let insuranceAmount = preCifBase * (insuranceRate / 100) / (1 - insuranceRate / 100);\n    if (insuranceAmount < minInsurance) {\n        insuranceAmount = minInsurance;\n    }\n    // ============================================\n    // STEP 12: BANK CHARGES\n    // ============================================\n    const invoiceValue = preCifBase + insuranceAmount;\n    const bankCharges = invoiceValue * (bankChargeRate / 100);\n    // ============================================\n    // STEP 13: PROFIT MARGIN (Applied at selected tier)\n    // ============================================\n    const costBaseCIF = invoiceValue + bankCharges;\n    // Calculate profit base based on selected tier\n    let profitBase = 0;\n    if (selectedTier === \"exFactory\") {\n        profitBase = exFactoryINR;\n    } else if (selectedTier === \"fob\") {\n        profitBase = fobINR;\n    } else {\n        // CIF - use full cost base\n        profitBase = costBaseCIF;\n    }\n    let profitAmount = 0;\n    if (profitType === \"percentage\") {\n        profitAmount = profitBase * (profitRate / 100);\n    } else if (profitType === \"per_container\") {\n        profitAmount = profitRate * containerCount;\n    } else if (profitType === \"per_unit\") {\n        profitAmount = profitRate * quantity;\n    } else {\n        profitAmount = profitRate; // Fixed amount\n    }\n    // ============================================\n    // STEP 14: FINAL PRICES WITH PROFIT AT SELECTED TIER\n    // ============================================\n    // Calculate final prices based on selected tier\n    let exFactoryFinalINR = exFactoryINR;\n    let fobFinalINR = fobINR;\n    let cifFinalINR = costBaseCIF;\n    if (selectedTier === \"exFactory\") {\n        // Profit added to Ex Factory only\n        exFactoryFinalINR = exFactoryINR + profitAmount;\n        fobFinalINR = fobINR; // No profit in FOB/CIF\n        cifFinalINR = costBaseCIF;\n    } else if (selectedTier === \"fob\") {\n        // Profit added to FOB\n        exFactoryFinalINR = exFactoryINR;\n        fobFinalINR = fobINR + profitAmount;\n        cifFinalINR = costBaseCIF;\n    } else {\n        // CIF - profit added to full cost (current behavior)\n        exFactoryFinalINR = exFactoryINR;\n        fobFinalINR = fobINR;\n        cifFinalINR = costBaseCIF + profitAmount;\n    }\n    const exFactoryFinalUSD = convertToUSD(exFactoryFinalINR, exchangeRate);\n    const fobFinalUSD = convertToUSD(fobFinalINR, exchangeRate);\n    const cifFinalUSD = convertToUSD(cifFinalINR, exchangeRate);\n    // ============================================\n    // RETURN COMPLETE BREAKDOWN\n    // ============================================\n    return {\n        // Container info\n        containerType: (containerType === null || containerType === void 0 ? void 0 : containerType.name) || \"N/A\",\n        containerCode: (containerType === null || containerType === void 0 ? void 0 : containerType.code) || \"N/A\",\n        qtyPerContainer,\n        containerCount,\n        // Selected pricing tier info\n        selectedTier,\n        tierLabels: {\n            exFactory: \"Ex Factory\",\n            fob: \"FOB (Free on Board)\",\n            cif: \"CIF (Cost Insurance Freight)\"\n        },\n        // Main prices (with profit applied at selected tier)\n        exFactory: {\n            inr: roundToTwo(exFactoryFinalINR),\n            usd: roundToTwo(exFactoryFinalUSD),\n            baseInr: roundToTwo(exFactoryINR),\n            baseUsd: roundToTwo(exFactoryUSD)\n        },\n        fob: {\n            inr: roundToTwo(fobFinalINR),\n            usd: roundToTwo(fobFinalUSD),\n            baseInr: roundToTwo(fobINR),\n            baseUsd: roundToTwo(fobUSD)\n        },\n        cif: {\n            inr: roundToTwo(cifFinalINR),\n            usd: roundToTwo(cifFinalUSD),\n            baseInr: roundToTwo(costBaseCIF),\n            baseUsd: roundToTwo(convertToUSD(costBaseCIF, exchangeRate))\n        },\n        // Per unit prices (using final prices with profit)\n        perUnit: {\n            exFactory: roundToTwo(exFactoryFinalUSD / quantity),\n            fob: roundToTwo(fobFinalUSD / quantity),\n            cif: roundToTwo(cifFinalUSD / quantity)\n        },\n        // Detailed breakdown\n        breakdown: {\n            productBase: {\n                label: \"Product Base Price\",\n                perUnit: basePrice,\n                quantity,\n                total: roundToTwo(exFactoryINR),\n                chargeType: \"per_unit\"\n            },\n            localFreight: {\n                label: \"Local Freight\",\n                perContainer: localFreightPerContainer,\n                containers: containerCount,\n                total: roundToTwo(localFreightTotal),\n                chargeType: \"per_container\"\n            },\n            handling: handlingCosts,\n            port: {\n                label: \"Port Charges\",\n                handling: roundToTwo(portHandlingTotal),\n                cha: roundToTwo(chaTotal),\n                customs: roundToTwo(customsTotal),\n                total: roundToTwo(portCosts.total),\n                chargeType: \"mixed\"\n            },\n            misc: miscCosts,\n            certifications: {\n                items: certBreakdown,\n                total: roundToTwo(certificationTotal)\n            },\n            ecgc: {\n                label: \"ECGC Premium\",\n                rate: ecgcRate,\n                total: roundToTwo(ecgcAmount),\n                chargeType: \"percentage\"\n            },\n            freight: {\n                label: \"International Freight\",\n                perContainer: freightPerContainer,\n                containers: containerCount,\n                currency: freightCurrency,\n                foreignTotal: roundToTwo(freightTotalForeign),\n                conversionRate: freightConversionRate,\n                exchangeRate: exchangeRate + bankMargin,\n                inrTotal: roundToTwo(freightINR),\n                gstRate: freightGST,\n                gstAmount: roundToTwo(freightGSTAmount),\n                totalWithGST: roundToTwo(freightWithGST),\n                chargeType: \"per_container\"\n            },\n            insurance: {\n                label: \"Marine Insurance\",\n                rate: insuranceRate,\n                total: roundToTwo(insuranceAmount),\n                chargeType: \"percentage\"\n            },\n            bankCharges: {\n                label: \"Bank Charges\",\n                rate: bankChargeRate,\n                total: roundToTwo(bankCharges),\n                chargeType: \"percentage\"\n            },\n            profit: {\n                label: \"Company Margin\",\n                type: profitType,\n                rate: profitRate,\n                total: roundToTwo(profitAmount)\n            }\n        },\n        // Summary by charge type\n        summary: {\n            perShipmentCosts: roundToTwo(handlingCosts.perShipment + chaTotal + customsTotal + miscCosts.perShipment + certificationTotal + ecgcAmount + insuranceAmount + bankCharges + profitAmount),\n            perContainerCosts: roundToTwo(localFreightTotal + handlingCosts.perContainer + portHandlingTotal + miscCosts.perContainer + freightWithGST)\n        },\n        // Currency info\n        currency: {\n            exchange: exchangeRate,\n            bankMargin,\n            effective: exchangeRate + bankMargin\n        }\n    };\n}\n// ============================================\n// UTILITY FUNCTIONS\n// ============================================\n/**\r\n * Round to 2 decimal places\r\n */ function roundToTwo(value) {\n    return Math.round((value || 0) * 100) / 100;\n}\n/**\r\n * Format currency (INR)\r\n */ function formatINR(amount) {\n    return new Intl.NumberFormat(\"en-IN\", {\n        style: \"currency\",\n        currency: \"INR\",\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).format(amount || 0);\n}\n/**\r\n * Format currency (USD)\r\n */ function formatUSD(amount) {\n    return new Intl.NumberFormat(\"en-US\", {\n        style: \"currency\",\n        currency: \"USD\",\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).format(amount || 0);\n}\n/**\r\n * Format number with commas (Indian style)\r\n */ function formatNumber(num) {\n    return new Intl.NumberFormat(\"en-IN\").format(num || 0);\n}\n/**\r\n * Format as percentage\r\n */ function formatPercent(rate) {\n    return \"\".concat(rate, \"%\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM5QixPQUFPLEdBQVEsT0FBTEEsTUFBSztBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2NhbGN1bGF0b3IuanM/M2MyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQVJPVkFWRSBHTE9CQUwgLSBFeHBvcnQgUmF0ZSBDYWxjdWxhdG9yIEVuZ2luZSB2MlxyXG4gKiBDb250YWluZXItQmFzZWQgRkNMIEV4cG9ydCBQcmljaW5nIFN5c3RlbVxyXG4gKiBcclxuICogQ2FsY3VsYXRpb24gRmxvdzpcclxuICogRVgtRkFDVE9SWSDihpIgQ29udGFpbmVyIENvdW50IOKGkiBMb2NhbCBGcmVpZ2h0IOKGkiBIYW5kbGluZyDihpIgUG9ydCDihpIgRk9CXHJcbiAqIOKGkiBFQ0dDIOKGkiBJbnQnbCBGcmVpZ2h0IOKGkiBDdXJyZW5jeSDihpIgSW5zdXJhbmNlIOKGkiBCYW5rIOKGkiBQcm9maXQg4oaSIENJRlxyXG4gKi9cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIENPTlRBSU5FUiBDQUxDVUxBVElPTlxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBudW1iZXIgb2YgY29udGFpbmVycyByZXF1aXJlZFxyXG4gKiBAcGFyYW0ge251bWJlcn0gcXVhbnRpdHkgLSBUb3RhbCBxdWFudGl0eSBvcmRlcmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBxdHlQZXJDb250YWluZXIgLSBIb3cgbXVjaCBmaXRzIGluIDEgY29udGFpbmVyICh1c2VyIGRlZmluZWQpXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBjb250YWluZXJzIG5lZWRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRhaW5lcnMocXVhbnRpdHksIHF0eVBlckNvbnRhaW5lcikge1xyXG4gICAgaWYgKCFxdWFudGl0eSB8fCAhcXR5UGVyQ29udGFpbmVyIHx8IHF0eVBlckNvbnRhaW5lciA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHF1YW50aXR5IC8gcXR5UGVyQ29udGFpbmVyKTtcclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gQ1VSUkVOQ1kgQ09OVkVSU0lPTlxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgZm9yZWlnbiBjdXJyZW5jeSB0byBJTlIgd2l0aCBiYW5rIG1hcmdpblxyXG4gKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gQW1vdW50IGluIGZvcmVpZ24gY3VycmVuY3lcclxuICogQHBhcmFtIHtudW1iZXJ9IGV4Y2hhbmdlUmF0ZSAtIEJhc2UgZXhjaGFuZ2UgcmF0ZSB0byBJTlJcclxuICogQHBhcmFtIHtudW1iZXJ9IGJhbmtNYXJnaW4gLSBCYW5rJ3MgbWFyZ2luIChlLmcuLCAwLjUwKVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBbW91bnQgaW4gSU5SXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvSU5SKGFtb3VudCwgZXhjaGFuZ2VSYXRlLCBiYW5rTWFyZ2luID0gMCkge1xyXG4gICAgY29uc3QgZWZmZWN0aXZlUmF0ZSA9IGV4Y2hhbmdlUmF0ZSArIGJhbmtNYXJnaW47XHJcbiAgICByZXR1cm4gYW1vdW50ICogZWZmZWN0aXZlUmF0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgSU5SIHRvIFVTRCBmb3IgZGlzcGxheVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYW1vdW50SU5SXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB1c2RSYXRlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvVVNEKGFtb3VudElOUiwgdXNkUmF0ZSkge1xyXG4gICAgaWYgKCF1c2RSYXRlIHx8IHVzZFJhdGUgPD0gMCkgcmV0dXJuIDA7XHJcbiAgICByZXR1cm4gYW1vdW50SU5SIC8gdXNkUmF0ZTtcclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gQ09TVCBBR0dSRUdBVElPTlxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBjb3N0cyBiYXNlZCBvbiBjaGFyZ2UgdHlwZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBjb3N0SGVhZHMgLSBBcnJheSBvZiBjb3N0IGhlYWQgb2JqZWN0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gY29udGFpbmVyQ291bnQgLSBOdW1iZXIgb2YgY29udGFpbmVyc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gcXVhbnRpdHkgLSBUb3RhbCBxdWFudGl0eVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVZhbHVlIC0gQmFzZSB2YWx1ZSBmb3IgcGVyY2VudGFnZSBjYWxjdWxhdGlvbnNcclxuICogQHJldHVybnMge09iamVjdH0gQ2F0ZWdvcml6ZWQgY29zdHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDb3N0SGVhZHMoY29zdEhlYWRzLCBjb250YWluZXJDb3VudCwgcXVhbnRpdHksIGJhc2VWYWx1ZSA9IDApIHtcclxuICAgIGxldCBwZXJTaGlwbWVudFRvdGFsID0gMDtcclxuICAgIGxldCBwZXJDb250YWluZXJUb3RhbCA9IDA7XHJcbiAgICBjb25zdCBicmVha2Rvd24gPSBbXTtcclxuXHJcbiAgICBjb3N0SGVhZHMuZm9yRWFjaChjb3N0ID0+IHtcclxuICAgICAgICBpZiAoIWNvc3QuaXNfYWN0aXZlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBhbW91bnQgPSAwO1xyXG4gICAgICAgIGxldCBkaXNwbGF5QW1vdW50ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKGNvc3QuY2FsY3VsYXRpb25fYmFzZSA9PT0gJ3BlcmNlbnRhZ2UnKSB7XHJcbiAgICAgICAgICAgIGFtb3VudCA9IGJhc2VWYWx1ZSAqIChjb3N0LnBlcmNlbnRhZ2VfcmF0ZSAvIDEwMCk7XHJcbiAgICAgICAgICAgIGRpc3BsYXlBbW91bnQgPSBhbW91bnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdChjb3N0LmJhc2VfYW1vdW50KSB8fCAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvc3QuY2hhcmdlX3R5cGUgPT09ICdwZXJfY29udGFpbmVyJykge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheUFtb3VudCA9IGFtb3VudCAqIGNvbnRhaW5lckNvdW50O1xyXG4gICAgICAgICAgICAgICAgcGVyQ29udGFpbmVyVG90YWwgKz0gZGlzcGxheUFtb3VudDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb3N0LmNoYXJnZV90eXBlID09PSAncGVyX3VuaXQnKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5QW1vdW50ID0gYW1vdW50ICogcXVhbnRpdHk7XHJcbiAgICAgICAgICAgICAgICBwZXJTaGlwbWVudFRvdGFsICs9IGRpc3BsYXlBbW91bnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwZXJfc2hpcG1lbnRcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlBbW91bnQgPSBhbW91bnQ7XHJcbiAgICAgICAgICAgICAgICBwZXJTaGlwbWVudFRvdGFsICs9IGRpc3BsYXlBbW91bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXNwbGF5QW1vdW50ID4gMCkge1xyXG4gICAgICAgICAgICBicmVha2Rvd24ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBjb3N0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgICBjaGFyZ2VUeXBlOiBjb3N0LmNoYXJnZV90eXBlLFxyXG4gICAgICAgICAgICAgICAgdW5pdEFtb3VudDogYW1vdW50LFxyXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IGNvc3QuY2hhcmdlX3R5cGUgPT09ICdwZXJfY29udGFpbmVyJyA/IGNvbnRhaW5lckNvdW50IDogMSxcclxuICAgICAgICAgICAgICAgIHRvdGFsOiBkaXNwbGF5QW1vdW50XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGVyU2hpcG1lbnQ6IHJvdW5kVG9Ud28ocGVyU2hpcG1lbnRUb3RhbCksXHJcbiAgICAgICAgcGVyQ29udGFpbmVyOiByb3VuZFRvVHdvKHBlckNvbnRhaW5lclRvdGFsKSxcclxuICAgICAgICB0b3RhbDogcm91bmRUb1R3byhwZXJTaGlwbWVudFRvdGFsICsgcGVyQ29udGFpbmVyVG90YWwpLFxyXG4gICAgICAgIGJyZWFrZG93blxyXG4gICAgfTtcclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gTUFJTiBDQUxDVUxBVElPTiBFTkdJTkVcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbi8qKlxyXG4gKiBDb21wbGV0ZSBleHBvcnQgcHJpY2luZyBjYWxjdWxhdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gQWxsIGlucHV0IHBhcmFtZXRlcnNcclxuICogQHJldHVybnMge09iamVjdH0gQ29tcGxldGUgcHJpY2luZyBicmVha2Rvd25cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVFeHBvcnRQcmljaW5nKHtcclxuICAgIC8vIFByb2R1Y3QgJiBRdWFudGl0eVxyXG4gICAgcHJvZHVjdCxcclxuICAgIHF1YW50aXR5LFxyXG5cclxuICAgIC8vIENvbnRhaW5lclxyXG4gICAgY29udGFpbmVyVHlwZSxcclxuICAgIHF0eVBlckNvbnRhaW5lcixcclxuXHJcbiAgICAvLyBMb2NhdGlvbnNcclxuICAgIGxvY2FsRnJlaWdodFJhdGUsICAvLyBSYXRlIHBlciBjb250YWluZXIgaW4gSU5SXHJcblxyXG4gICAgLy8gUG9ydCBjaGFyZ2VzXHJcbiAgICBwb3J0SGFuZGxpbmdQZXJDb250YWluZXIsXHJcbiAgICBjaGFDaGFyZ2VzLFxyXG4gICAgY3VzdG9tc0NsZWFyYW5jZSxcclxuXHJcbiAgICAvLyBDb3N0IGhlYWRzXHJcbiAgICBjb3N0SGVhZHMgPSBbXSxcclxuXHJcbiAgICAvLyBDZXJ0aWZpY2F0aW9uc1xyXG4gICAgY2VydGlmaWNhdGlvbnMgPSBbXSxcclxuXHJcbiAgICAvLyBJbnRlcm5hdGlvbmFsIEZyZWlnaHRcclxuICAgIGZyZWlnaHRSYXRlLCAgLy8gUGVyIGNvbnRhaW5lciBpbiBmb3JlaWduIGN1cnJlbmN5XHJcbiAgICBmcmVpZ2h0Q3VycmVuY3kgPSAnVVNEJyxcclxuICAgIGZyZWlnaHRDb252ZXJzaW9uUmF0ZSA9IDEuMCxcclxuICAgIGZyZWlnaHRHU1QgPSA1LFxyXG5cclxuICAgIC8vIEN1cnJlbmN5IHNldHRpbmdzXHJcbiAgICBleGNoYW5nZVJhdGUgPSA4My41MCxcclxuICAgIGJhbmtNYXJnaW4gPSAwLjUwLFxyXG5cclxuICAgIC8vIEVDR0NcclxuICAgIGVjZ2NSYXRlID0gMC41MCxcclxuXHJcbiAgICAvLyBJbnN1cmFuY2VcclxuICAgIGluc3VyYW5jZVJhdGUgPSAwLjUwLFxyXG4gICAgbWluSW5zdXJhbmNlID0gNTAwMCxcclxuXHJcbiAgICAvLyBCYW5rIGNoYXJnZXNcclxuICAgIGJhbmtDaGFyZ2VSYXRlID0gMC4yNSxcclxuXHJcbiAgICAvLyBQcm9maXRcclxuICAgIHByb2ZpdFJhdGUgPSA1LjAsXHJcbiAgICBwcm9maXRUeXBlID0gJ3BlcmNlbnRhZ2UnLFxyXG5cclxuICAgIC8vIERpc3BsYXkgY3VycmVuY3lcclxuICAgIGRpc3BsYXlDdXJyZW5jeSA9ICdVU0QnLFxyXG5cclxuICAgIC8vIFNlbGVjdGVkIHByaWNpbmcgdGllcjogJ2V4RmFjdG9yeScsICdmb2InLCBvciAnY2lmJ1xyXG4gICAgLy8gUHJvZml0IHdpbGwgYmUgY2FsY3VsYXRlZCBhdCB0aGUgc2VsZWN0ZWQgdGllclxyXG4gICAgc2VsZWN0ZWRUaWVyID0gJ2NpZicsXHJcblxyXG4gICAgLy8gQ3VzdG9tIGNoYXJnZXMgKGluIElOUilcclxuICAgIHBhY2thZ2luZ0NoYXJnZXMgPSAwLFxyXG4gICAgZXh0cmFDaGFyZ2VzID0gMFxyXG59KSB7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgMTogQ09OVEFJTkVSIENBTENVTEFUSU9OXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgY29uc3QgY29udGFpbmVyQ291bnQgPSBjYWxjdWxhdGVDb250YWluZXJzKHF1YW50aXR5LCBxdHlQZXJDb250YWluZXIpO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBTVEVQIDI6IFBBQ0tBR0lORyBDSEFSR0VTIChwZXIgYm94LCBhZGRlZCB0byBwcm9kdWN0IGNvc3QpXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgY29uc3QgdG90YWxQYWNrYWdpbmdDaGFyZ2VzID0gcGFyc2VGbG9hdChwYWNrYWdpbmdDaGFyZ2VzKSB8fCAwO1xyXG4gICAgY29uc3QgdG90YWxFeHRyYUNoYXJnZXNBbW91bnQgPSBwYXJzZUZsb2F0KGV4dHJhQ2hhcmdlcykgfHwgMDtcclxuICAgIGNvbnN0IGN1c3RvbUNoYXJnZXNUb3RhbCA9IHRvdGFsUGFja2FnaW5nQ2hhcmdlcyArIHRvdGFsRXh0cmFDaGFyZ2VzQW1vdW50O1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBTVEVQIDM6IEVYLUZBQ1RPUlkgQ09TVCAoUHJvZHVjdCArIFBhY2thZ2luZylcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBjb25zdCBiYXNlUHJpY2UgPSBwYXJzZUZsb2F0KHByb2R1Y3QuYmFzZV9wcmljZV91c2QpIHx8IDA7XHJcbiAgICBjb25zdCBleEZhY3RvcnlQcm9kdWN0VVNEID0gYmFzZVByaWNlICogcXVhbnRpdHk7XHJcbiAgICBjb25zdCBleEZhY3RvcnlQcm9kdWN0SU5SID0gY29udmVydFRvSU5SKGV4RmFjdG9yeVByb2R1Y3RVU0QsIGV4Y2hhbmdlUmF0ZSwgMCk7XHJcbiAgICAvLyBBZGQgcGFja2FnaW5nIGFuZCBleHRyYSBjaGFyZ2VzIHRvIEV4LUZhY3RvcnlcclxuICAgIGNvbnN0IGV4RmFjdG9yeUlOUiA9IGV4RmFjdG9yeVByb2R1Y3RJTlIgKyBjdXN0b21DaGFyZ2VzVG90YWw7XHJcbiAgICBjb25zdCBleEZhY3RvcnlVU0QgPSBjb252ZXJ0VG9VU0QoZXhGYWN0b3J5SU5SLCBleGNoYW5nZVJhdGUpO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBTVEVQIDM6IExPQ0FMIEZSRUlHSFQgKFBlciBDb250YWluZXIpXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgY29uc3QgbG9jYWxGcmVpZ2h0UGVyQ29udGFpbmVyID0gcGFyc2VGbG9hdChsb2NhbEZyZWlnaHRSYXRlKSB8fCAwO1xyXG4gICAgY29uc3QgbG9jYWxGcmVpZ2h0VG90YWwgPSBsb2NhbEZyZWlnaHRQZXJDb250YWluZXIgKiBjb250YWluZXJDb3VudDtcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gU1RFUCA0OiBIQU5ETElORyAmIExBQk9VUiAoRnJvbSBDb3N0IEhlYWRzKVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IGhhbmRsaW5nQ29zdHMgPSBjYWxjdWxhdGVDb3N0SGVhZHMoXHJcbiAgICAgICAgY29zdEhlYWRzLmZpbHRlcihjID0+IGMuY2F0ZWdvcnkgPT09ICdoYW5kbGluZycpLFxyXG4gICAgICAgIGNvbnRhaW5lckNvdW50LFxyXG4gICAgICAgIHF1YW50aXR5LFxyXG4gICAgICAgIGV4RmFjdG9yeUlOUlxyXG4gICAgKTtcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gU1RFUCA1OiBQT1JUIENIQVJHRVNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBjb25zdCBwb3J0SGFuZGxpbmdUb3RhbCA9IChwYXJzZUZsb2F0KHBvcnRIYW5kbGluZ1BlckNvbnRhaW5lcikgfHwgMCkgKiBjb250YWluZXJDb3VudDtcclxuICAgIGNvbnN0IGNoYVRvdGFsID0gcGFyc2VGbG9hdChjaGFDaGFyZ2VzKSB8fCAwOyAgLy8gUGVyIHNoaXBtZW50XHJcbiAgICBjb25zdCBjdXN0b21zVG90YWwgPSBwYXJzZUZsb2F0KGN1c3RvbXNDbGVhcmFuY2UpIHx8IDA7ICAvLyBQZXIgc2hpcG1lbnRcclxuXHJcbiAgICBjb25zdCBwb3J0Q29zdHMgPSB7XHJcbiAgICAgICAgaGFuZGxpbmc6IHBvcnRIYW5kbGluZ1RvdGFsLFxyXG4gICAgICAgIGNoYTogY2hhVG90YWwsXHJcbiAgICAgICAgY3VzdG9tczogY3VzdG9tc1RvdGFsLFxyXG4gICAgICAgIHRvdGFsOiBwb3J0SGFuZGxpbmdUb3RhbCArIGNoYVRvdGFsICsgY3VzdG9tc1RvdGFsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBTVEVQIDY6IE1JU0NFTExBTkVPVVMgQ0hBUkdFU1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IG1pc2NDb3N0cyA9IGNhbGN1bGF0ZUNvc3RIZWFkcyhcclxuICAgICAgICBjb3N0SGVhZHMuZmlsdGVyKGMgPT4gYy5jYXRlZ29yeSA9PT0gJ21pc2MnKSxcclxuICAgICAgICBjb250YWluZXJDb3VudCxcclxuICAgICAgICBxdWFudGl0eSxcclxuICAgICAgICBleEZhY3RvcnlJTlJcclxuICAgICk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgNzogQ0VSVElGSUNBVElPTlNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBsZXQgY2VydGlmaWNhdGlvblRvdGFsID0gMDtcclxuICAgIGNvbnN0IGNlcnRCcmVha2Rvd24gPSBbXTtcclxuXHJcbiAgICBjZXJ0aWZpY2F0aW9ucy5mb3JFYWNoKGNlcnQgPT4ge1xyXG4gICAgICAgIGxldCBjb3N0ID0gMDtcclxuICAgICAgICBpZiAoY2VydC5jb3N0X3BlcmNlbnRhZ2UgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvc3QgPSBleEZhY3RvcnlJTlIgKiAoY2VydC5jb3N0X3BlcmNlbnRhZ2UgLyAxMDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvc3QgPSBwYXJzZUZsb2F0KGNlcnQuY29zdF9mbGF0KSB8fCAwO1xyXG4gICAgICAgICAgICBpZiAoY2VydC5jaGFyZ2VfdHlwZSA9PT0gJ3Blcl9jb250YWluZXInKSB7XHJcbiAgICAgICAgICAgICAgICBjb3N0ID0gY29zdCAqIGNvbnRhaW5lckNvdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNlcnRpZmljYXRpb25Ub3RhbCArPSBjb3N0O1xyXG4gICAgICAgIGlmIChjb3N0ID4gMCkge1xyXG4gICAgICAgICAgICBjZXJ0QnJlYWtkb3duLnB1c2goeyBuYW1lOiBjZXJ0Lm5hbWUsIGNvc3Q6IHJvdW5kVG9Ud28oY29zdCkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgODogRk9CIENBTENVTEFUSU9OXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gTm90ZTogUGFja2FnaW5nIGFuZCBleHRyYSBjaGFyZ2VzIGFyZSBhbHJlYWR5IGluY2x1ZGVkIGluIGV4RmFjdG9yeUlOUlxyXG4gICAgY29uc3QgZm9iSU5SID0gZXhGYWN0b3J5SU5SXHJcbiAgICAgICAgKyBsb2NhbEZyZWlnaHRUb3RhbFxyXG4gICAgICAgICsgaGFuZGxpbmdDb3N0cy50b3RhbFxyXG4gICAgICAgICsgcG9ydENvc3RzLnRvdGFsXHJcbiAgICAgICAgKyBtaXNjQ29zdHMudG90YWxcclxuICAgICAgICArIGNlcnRpZmljYXRpb25Ub3RhbDtcclxuXHJcbiAgICBjb25zdCBmb2JVU0QgPSBjb252ZXJ0VG9VU0QoZm9iSU5SLCBleGNoYW5nZVJhdGUpO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBTVEVQIDk6IEVDR0MgKEV4cG9ydCBDcmVkaXQgR3VhcmFudGVlKVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IGVjZ2NBbW91bnQgPSBmb2JJTlIgKiAoZWNnY1JhdGUgLyAxMDApO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBTVEVQIDEwOiBJTlRFUk5BVElPTkFMIEZSRUlHSFRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBjb25zdCBmcmVpZ2h0UGVyQ29udGFpbmVyID0gcGFyc2VGbG9hdChmcmVpZ2h0UmF0ZSkgfHwgMDtcclxuICAgIGNvbnN0IGZyZWlnaHRUb3RhbEZvcmVpZ24gPSBmcmVpZ2h0UGVyQ29udGFpbmVyICogY29udGFpbmVyQ291bnQ7XHJcblxyXG4gICAgLy8gQXBwbHkgZnJlaWdodCBjb252ZXJzaW9uIHJhdGVcclxuICAgIGNvbnN0IGZyZWlnaHRBZGp1c3RlZCA9IGZyZWlnaHRUb3RhbEZvcmVpZ24gKiAocGFyc2VGbG9hdChmcmVpZ2h0Q29udmVyc2lvblJhdGUpIHx8IDEpO1xyXG5cclxuICAgIC8vIENvbnZlcnQgdG8gSU5SIHdpdGggYmFuayBtYXJnaW5cclxuICAgIGNvbnN0IGZyZWlnaHRJTlIgPSBjb252ZXJ0VG9JTlIoZnJlaWdodEFkanVzdGVkLCBleGNoYW5nZVJhdGUsIGJhbmtNYXJnaW4pO1xyXG5cclxuICAgIC8vIEFkZCBHU1Qgb24gZnJlaWdodFxyXG4gICAgY29uc3QgZnJlaWdodEdTVEFtb3VudCA9IGZyZWlnaHRJTlIgKiAoZnJlaWdodEdTVCAvIDEwMCk7XHJcbiAgICBjb25zdCBmcmVpZ2h0V2l0aEdTVCA9IGZyZWlnaHRJTlIgKyBmcmVpZ2h0R1NUQW1vdW50O1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBTVEVQIDExOiBJTlNVUkFOQ0VcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBJbnN1cmFuY2UgaXMgY2FsY3VsYXRlZCBvbiBDSUYsIHNvIHdlIG5lZWQgaXRlcmF0aXZlIGNhbGN1bGF0aW9uXHJcbiAgICAvLyBDSUYgPSBGT0IgKyBGcmVpZ2h0ICsgSW5zdXJhbmNlXHJcbiAgICAvLyBJbnN1cmFuY2UgPSBJbnN1cmFuY2VSYXRlJSDDlyBDSUZcclxuICAgIC8vIFNvOiBJbnN1cmFuY2UgPSBJbnN1cmFuY2VSYXRlJSDDlyAoRk9CICsgRnJlaWdodCArIEluc3VyYW5jZSlcclxuICAgIC8vIEluc3VyYW5jZSDDlyAoMSAtIEluc3VyYW5jZVJhdGUlKSA9IEluc3VyYW5jZVJhdGUlIMOXIChGT0IgKyBGcmVpZ2h0KVxyXG4gICAgLy8gSW5zdXJhbmNlID0gKEluc3VyYW5jZVJhdGUlIMOXIChGT0IgKyBGcmVpZ2h0KSkgLyAoMSAtIEluc3VyYW5jZVJhdGUlKVxyXG5cclxuICAgIGNvbnN0IHByZUNpZkJhc2UgPSBmb2JJTlIgKyBlY2djQW1vdW50ICsgZnJlaWdodFdpdGhHU1Q7XHJcbiAgICBsZXQgaW5zdXJhbmNlQW1vdW50ID0gKHByZUNpZkJhc2UgKiAoaW5zdXJhbmNlUmF0ZSAvIDEwMCkpIC8gKDEgLSAoaW5zdXJhbmNlUmF0ZSAvIDEwMCkpO1xyXG5cclxuICAgIGlmIChpbnN1cmFuY2VBbW91bnQgPCBtaW5JbnN1cmFuY2UpIHtcclxuICAgICAgICBpbnN1cmFuY2VBbW91bnQgPSBtaW5JbnN1cmFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgMTI6IEJBTksgQ0hBUkdFU1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IGludm9pY2VWYWx1ZSA9IHByZUNpZkJhc2UgKyBpbnN1cmFuY2VBbW91bnQ7XHJcbiAgICBjb25zdCBiYW5rQ2hhcmdlcyA9IGludm9pY2VWYWx1ZSAqIChiYW5rQ2hhcmdlUmF0ZSAvIDEwMCk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgMTM6IFBST0ZJVCBNQVJHSU4gKEFwcGxpZWQgYXQgc2VsZWN0ZWQgdGllcilcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBjb25zdCBjb3N0QmFzZUNJRiA9IGludm9pY2VWYWx1ZSArIGJhbmtDaGFyZ2VzO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBwcm9maXQgYmFzZSBiYXNlZCBvbiBzZWxlY3RlZCB0aWVyXHJcbiAgICBsZXQgcHJvZml0QmFzZSA9IDA7XHJcbiAgICBpZiAoc2VsZWN0ZWRUaWVyID09PSAnZXhGYWN0b3J5Jykge1xyXG4gICAgICAgIHByb2ZpdEJhc2UgPSBleEZhY3RvcnlJTlI7XHJcbiAgICB9IGVsc2UgaWYgKHNlbGVjdGVkVGllciA9PT0gJ2ZvYicpIHtcclxuICAgICAgICBwcm9maXRCYXNlID0gZm9iSU5SO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBDSUYgLSB1c2UgZnVsbCBjb3N0IGJhc2VcclxuICAgICAgICBwcm9maXRCYXNlID0gY29zdEJhc2VDSUY7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHByb2ZpdEFtb3VudCA9IDA7XHJcbiAgICBpZiAocHJvZml0VHlwZSA9PT0gJ3BlcmNlbnRhZ2UnKSB7XHJcbiAgICAgICAgcHJvZml0QW1vdW50ID0gcHJvZml0QmFzZSAqIChwcm9maXRSYXRlIC8gMTAwKTtcclxuICAgIH0gZWxzZSBpZiAocHJvZml0VHlwZSA9PT0gJ3Blcl9jb250YWluZXInKSB7XHJcbiAgICAgICAgcHJvZml0QW1vdW50ID0gcHJvZml0UmF0ZSAqIGNvbnRhaW5lckNvdW50O1xyXG4gICAgfSBlbHNlIGlmIChwcm9maXRUeXBlID09PSAncGVyX3VuaXQnKSB7XHJcbiAgICAgICAgcHJvZml0QW1vdW50ID0gcHJvZml0UmF0ZSAqIHF1YW50aXR5O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9maXRBbW91bnQgPSBwcm9maXRSYXRlOyAgLy8gRml4ZWQgYW1vdW50XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFNURVAgMTQ6IEZJTkFMIFBSSUNFUyBXSVRIIFBST0ZJVCBBVCBTRUxFQ1RFRCBUSUVSXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBmaW5hbCBwcmljZXMgYmFzZWQgb24gc2VsZWN0ZWQgdGllclxyXG4gICAgbGV0IGV4RmFjdG9yeUZpbmFsSU5SID0gZXhGYWN0b3J5SU5SO1xyXG4gICAgbGV0IGZvYkZpbmFsSU5SID0gZm9iSU5SO1xyXG4gICAgbGV0IGNpZkZpbmFsSU5SID0gY29zdEJhc2VDSUY7XHJcblxyXG4gICAgaWYgKHNlbGVjdGVkVGllciA9PT0gJ2V4RmFjdG9yeScpIHtcclxuICAgICAgICAvLyBQcm9maXQgYWRkZWQgdG8gRXggRmFjdG9yeSBvbmx5XHJcbiAgICAgICAgZXhGYWN0b3J5RmluYWxJTlIgPSBleEZhY3RvcnlJTlIgKyBwcm9maXRBbW91bnQ7XHJcbiAgICAgICAgZm9iRmluYWxJTlIgPSBmb2JJTlI7IC8vIE5vIHByb2ZpdCBpbiBGT0IvQ0lGXHJcbiAgICAgICAgY2lmRmluYWxJTlIgPSBjb3N0QmFzZUNJRjtcclxuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRUaWVyID09PSAnZm9iJykge1xyXG4gICAgICAgIC8vIFByb2ZpdCBhZGRlZCB0byBGT0JcclxuICAgICAgICBleEZhY3RvcnlGaW5hbElOUiA9IGV4RmFjdG9yeUlOUjtcclxuICAgICAgICBmb2JGaW5hbElOUiA9IGZvYklOUiArIHByb2ZpdEFtb3VudDtcclxuICAgICAgICBjaWZGaW5hbElOUiA9IGNvc3RCYXNlQ0lGO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBDSUYgLSBwcm9maXQgYWRkZWQgdG8gZnVsbCBjb3N0IChjdXJyZW50IGJlaGF2aW9yKVxyXG4gICAgICAgIGV4RmFjdG9yeUZpbmFsSU5SID0gZXhGYWN0b3J5SU5SO1xyXG4gICAgICAgIGZvYkZpbmFsSU5SID0gZm9iSU5SO1xyXG4gICAgICAgIGNpZkZpbmFsSU5SID0gY29zdEJhc2VDSUYgKyBwcm9maXRBbW91bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXhGYWN0b3J5RmluYWxVU0QgPSBjb252ZXJ0VG9VU0QoZXhGYWN0b3J5RmluYWxJTlIsIGV4Y2hhbmdlUmF0ZSk7XHJcbiAgICBjb25zdCBmb2JGaW5hbFVTRCA9IGNvbnZlcnRUb1VTRChmb2JGaW5hbElOUiwgZXhjaGFuZ2VSYXRlKTtcclxuICAgIGNvbnN0IGNpZkZpbmFsVVNEID0gY29udmVydFRvVVNEKGNpZkZpbmFsSU5SLCBleGNoYW5nZVJhdGUpO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBSRVRVUk4gQ09NUExFVEUgQlJFQUtET1dOXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBDb250YWluZXIgaW5mb1xyXG4gICAgICAgIGNvbnRhaW5lclR5cGU6IGNvbnRhaW5lclR5cGU/Lm5hbWUgfHwgJ04vQScsXHJcbiAgICAgICAgY29udGFpbmVyQ29kZTogY29udGFpbmVyVHlwZT8uY29kZSB8fCAnTi9BJyxcclxuICAgICAgICBxdHlQZXJDb250YWluZXIsXHJcbiAgICAgICAgY29udGFpbmVyQ291bnQsXHJcblxyXG4gICAgICAgIC8vIFNlbGVjdGVkIHByaWNpbmcgdGllciBpbmZvXHJcbiAgICAgICAgc2VsZWN0ZWRUaWVyLFxyXG4gICAgICAgIHRpZXJMYWJlbHM6IHtcclxuICAgICAgICAgICAgZXhGYWN0b3J5OiAnRXggRmFjdG9yeScsXHJcbiAgICAgICAgICAgIGZvYjogJ0ZPQiAoRnJlZSBvbiBCb2FyZCknLFxyXG4gICAgICAgICAgICBjaWY6ICdDSUYgKENvc3QgSW5zdXJhbmNlIEZyZWlnaHQpJ1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIE1haW4gcHJpY2VzICh3aXRoIHByb2ZpdCBhcHBsaWVkIGF0IHNlbGVjdGVkIHRpZXIpXHJcbiAgICAgICAgZXhGYWN0b3J5OiB7XHJcbiAgICAgICAgICAgIGlucjogcm91bmRUb1R3byhleEZhY3RvcnlGaW5hbElOUiksXHJcbiAgICAgICAgICAgIHVzZDogcm91bmRUb1R3byhleEZhY3RvcnlGaW5hbFVTRCksXHJcbiAgICAgICAgICAgIGJhc2VJbnI6IHJvdW5kVG9Ud28oZXhGYWN0b3J5SU5SKSxcclxuICAgICAgICAgICAgYmFzZVVzZDogcm91bmRUb1R3byhleEZhY3RvcnlVU0QpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb2I6IHtcclxuICAgICAgICAgICAgaW5yOiByb3VuZFRvVHdvKGZvYkZpbmFsSU5SKSxcclxuICAgICAgICAgICAgdXNkOiByb3VuZFRvVHdvKGZvYkZpbmFsVVNEKSxcclxuICAgICAgICAgICAgYmFzZUlucjogcm91bmRUb1R3byhmb2JJTlIpLFxyXG4gICAgICAgICAgICBiYXNlVXNkOiByb3VuZFRvVHdvKGZvYlVTRClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNpZjoge1xyXG4gICAgICAgICAgICBpbnI6IHJvdW5kVG9Ud28oY2lmRmluYWxJTlIpLFxyXG4gICAgICAgICAgICB1c2Q6IHJvdW5kVG9Ud28oY2lmRmluYWxVU0QpLFxyXG4gICAgICAgICAgICBiYXNlSW5yOiByb3VuZFRvVHdvKGNvc3RCYXNlQ0lGKSxcclxuICAgICAgICAgICAgYmFzZVVzZDogcm91bmRUb1R3byhjb252ZXJ0VG9VU0QoY29zdEJhc2VDSUYsIGV4Y2hhbmdlUmF0ZSkpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUGVyIHVuaXQgcHJpY2VzICh1c2luZyBmaW5hbCBwcmljZXMgd2l0aCBwcm9maXQpXHJcbiAgICAgICAgcGVyVW5pdDoge1xyXG4gICAgICAgICAgICBleEZhY3Rvcnk6IHJvdW5kVG9Ud28oZXhGYWN0b3J5RmluYWxVU0QgLyBxdWFudGl0eSksXHJcbiAgICAgICAgICAgIGZvYjogcm91bmRUb1R3byhmb2JGaW5hbFVTRCAvIHF1YW50aXR5KSxcclxuICAgICAgICAgICAgY2lmOiByb3VuZFRvVHdvKGNpZkZpbmFsVVNEIC8gcXVhbnRpdHkpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRGV0YWlsZWQgYnJlYWtkb3duXHJcbiAgICAgICAgYnJlYWtkb3duOiB7XHJcbiAgICAgICAgICAgIHByb2R1Y3RCYXNlOiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1Byb2R1Y3QgQmFzZSBQcmljZScsXHJcbiAgICAgICAgICAgICAgICBwZXJVbml0OiBiYXNlUHJpY2UsXHJcbiAgICAgICAgICAgICAgICBxdWFudGl0eSxcclxuICAgICAgICAgICAgICAgIHRvdGFsOiByb3VuZFRvVHdvKGV4RmFjdG9yeUlOUiksXHJcbiAgICAgICAgICAgICAgICBjaGFyZ2VUeXBlOiAncGVyX3VuaXQnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxvY2FsRnJlaWdodDoge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdMb2NhbCBGcmVpZ2h0JyxcclxuICAgICAgICAgICAgICAgIHBlckNvbnRhaW5lcjogbG9jYWxGcmVpZ2h0UGVyQ29udGFpbmVyLFxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyczogY29udGFpbmVyQ291bnQsXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogcm91bmRUb1R3byhsb2NhbEZyZWlnaHRUb3RhbCksXHJcbiAgICAgICAgICAgICAgICBjaGFyZ2VUeXBlOiAncGVyX2NvbnRhaW5lcidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFuZGxpbmc6IGhhbmRsaW5nQ29zdHMsXHJcbiAgICAgICAgICAgIHBvcnQ6IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnUG9ydCBDaGFyZ2VzJyxcclxuICAgICAgICAgICAgICAgIGhhbmRsaW5nOiByb3VuZFRvVHdvKHBvcnRIYW5kbGluZ1RvdGFsKSxcclxuICAgICAgICAgICAgICAgIGNoYTogcm91bmRUb1R3byhjaGFUb3RhbCksXHJcbiAgICAgICAgICAgICAgICBjdXN0b21zOiByb3VuZFRvVHdvKGN1c3RvbXNUb3RhbCksXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogcm91bmRUb1R3byhwb3J0Q29zdHMudG90YWwpLFxyXG4gICAgICAgICAgICAgICAgY2hhcmdlVHlwZTogJ21peGVkJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtaXNjOiBtaXNjQ29zdHMsXHJcbiAgICAgICAgICAgIGNlcnRpZmljYXRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBpdGVtczogY2VydEJyZWFrZG93bixcclxuICAgICAgICAgICAgICAgIHRvdGFsOiByb3VuZFRvVHdvKGNlcnRpZmljYXRpb25Ub3RhbClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZWNnYzoge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdFQ0dDIFByZW1pdW0nLFxyXG4gICAgICAgICAgICAgICAgcmF0ZTogZWNnY1JhdGUsXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogcm91bmRUb1R3byhlY2djQW1vdW50KSxcclxuICAgICAgICAgICAgICAgIGNoYXJnZVR5cGU6ICdwZXJjZW50YWdlJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmcmVpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0ludGVybmF0aW9uYWwgRnJlaWdodCcsXHJcbiAgICAgICAgICAgICAgICBwZXJDb250YWluZXI6IGZyZWlnaHRQZXJDb250YWluZXIsXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJzOiBjb250YWluZXJDb3VudCxcclxuICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBmcmVpZ2h0Q3VycmVuY3ksXHJcbiAgICAgICAgICAgICAgICBmb3JlaWduVG90YWw6IHJvdW5kVG9Ud28oZnJlaWdodFRvdGFsRm9yZWlnbiksXHJcbiAgICAgICAgICAgICAgICBjb252ZXJzaW9uUmF0ZTogZnJlaWdodENvbnZlcnNpb25SYXRlLFxyXG4gICAgICAgICAgICAgICAgZXhjaGFuZ2VSYXRlOiBleGNoYW5nZVJhdGUgKyBiYW5rTWFyZ2luLFxyXG4gICAgICAgICAgICAgICAgaW5yVG90YWw6IHJvdW5kVG9Ud28oZnJlaWdodElOUiksXHJcbiAgICAgICAgICAgICAgICBnc3RSYXRlOiBmcmVpZ2h0R1NULFxyXG4gICAgICAgICAgICAgICAgZ3N0QW1vdW50OiByb3VuZFRvVHdvKGZyZWlnaHRHU1RBbW91bnQpLFxyXG4gICAgICAgICAgICAgICAgdG90YWxXaXRoR1NUOiByb3VuZFRvVHdvKGZyZWlnaHRXaXRoR1NUKSxcclxuICAgICAgICAgICAgICAgIGNoYXJnZVR5cGU6ICdwZXJfY29udGFpbmVyJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnN1cmFuY2U6IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnTWFyaW5lIEluc3VyYW5jZScsXHJcbiAgICAgICAgICAgICAgICByYXRlOiBpbnN1cmFuY2VSYXRlLFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IHJvdW5kVG9Ud28oaW5zdXJhbmNlQW1vdW50KSxcclxuICAgICAgICAgICAgICAgIGNoYXJnZVR5cGU6ICdwZXJjZW50YWdlJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBiYW5rQ2hhcmdlczoge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdCYW5rIENoYXJnZXMnLFxyXG4gICAgICAgICAgICAgICAgcmF0ZTogYmFua0NoYXJnZVJhdGUsXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogcm91bmRUb1R3byhiYW5rQ2hhcmdlcyksXHJcbiAgICAgICAgICAgICAgICBjaGFyZ2VUeXBlOiAncGVyY2VudGFnZSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvZml0OiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0NvbXBhbnkgTWFyZ2luJyxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHByb2ZpdFR5cGUsXHJcbiAgICAgICAgICAgICAgICByYXRlOiBwcm9maXRSYXRlLFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IHJvdW5kVG9Ud28ocHJvZml0QW1vdW50KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gU3VtbWFyeSBieSBjaGFyZ2UgdHlwZVxyXG4gICAgICAgIHN1bW1hcnk6IHtcclxuICAgICAgICAgICAgcGVyU2hpcG1lbnRDb3N0czogcm91bmRUb1R3byhcclxuICAgICAgICAgICAgICAgIGhhbmRsaW5nQ29zdHMucGVyU2hpcG1lbnQgK1xyXG4gICAgICAgICAgICAgICAgY2hhVG90YWwgK1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tc1RvdGFsICtcclxuICAgICAgICAgICAgICAgIG1pc2NDb3N0cy5wZXJTaGlwbWVudCArXHJcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0aW9uVG90YWwgK1xyXG4gICAgICAgICAgICAgICAgZWNnY0Ftb3VudCArXHJcbiAgICAgICAgICAgICAgICBpbnN1cmFuY2VBbW91bnQgK1xyXG4gICAgICAgICAgICAgICAgYmFua0NoYXJnZXMgK1xyXG4gICAgICAgICAgICAgICAgcHJvZml0QW1vdW50XHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIHBlckNvbnRhaW5lckNvc3RzOiByb3VuZFRvVHdvKFxyXG4gICAgICAgICAgICAgICAgbG9jYWxGcmVpZ2h0VG90YWwgK1xyXG4gICAgICAgICAgICAgICAgaGFuZGxpbmdDb3N0cy5wZXJDb250YWluZXIgK1xyXG4gICAgICAgICAgICAgICAgcG9ydEhhbmRsaW5nVG90YWwgK1xyXG4gICAgICAgICAgICAgICAgbWlzY0Nvc3RzLnBlckNvbnRhaW5lciArXHJcbiAgICAgICAgICAgICAgICBmcmVpZ2h0V2l0aEdTVFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gQ3VycmVuY3kgaW5mb1xyXG4gICAgICAgIGN1cnJlbmN5OiB7XHJcbiAgICAgICAgICAgIGV4Y2hhbmdlOiBleGNoYW5nZVJhdGUsXHJcbiAgICAgICAgICAgIGJhbmtNYXJnaW4sXHJcbiAgICAgICAgICAgIGVmZmVjdGl2ZTogZXhjaGFuZ2VSYXRlICsgYmFua01hcmdpblxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFVUSUxJVFkgRlVOQ1RJT05TXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4vKipcclxuICogUm91bmQgdG8gMiBkZWNpbWFsIHBsYWNlc1xyXG4gKi9cclxuZnVuY3Rpb24gcm91bmRUb1R3byh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKHZhbHVlIHx8IDApICogMTAwKSAvIDEwMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBjdXJyZW5jeSAoSU5SKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdElOUihhbW91bnQpIHtcclxuICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoJ2VuLUlOJywge1xyXG4gICAgICAgIHN0eWxlOiAnY3VycmVuY3knLFxyXG4gICAgICAgIGN1cnJlbmN5OiAnSU5SJyxcclxuICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXHJcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyXHJcbiAgICB9KS5mb3JtYXQoYW1vdW50IHx8IDApO1xyXG59XHJcblxyXG4vKipcclxuICogRm9ybWF0IGN1cnJlbmN5IChVU0QpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VVNEKGFtb3VudCkge1xyXG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tVVMnLCB7XHJcbiAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXHJcbiAgICAgICAgY3VycmVuY3k6ICdVU0QnLFxyXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcclxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDJcclxuICAgIH0pLmZvcm1hdChhbW91bnQgfHwgMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgbnVtYmVyIHdpdGggY29tbWFzIChJbmRpYW4gc3R5bGUpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSkge1xyXG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tSU4nKS5mb3JtYXQobnVtIHx8IDApO1xyXG59XHJcblxyXG4vKipcclxuICogRm9ybWF0IGFzIHBlcmNlbnRhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRQZXJjZW50KHJhdGUpIHtcclxuICAgIHJldHVybiBgJHtyYXRlfSVgO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVDb250YWluZXJzIiwicXVhbnRpdHkiLCJxdHlQZXJDb250YWluZXIiLCJNYXRoIiwiY2VpbCIsImNvbnZlcnRUb0lOUiIsImFtb3VudCIsImV4Y2hhbmdlUmF0ZSIsImJhbmtNYXJnaW4iLCJlZmZlY3RpdmVSYXRlIiwiY29udmVydFRvVVNEIiwiYW1vdW50SU5SIiwidXNkUmF0ZSIsImNhbGN1bGF0ZUNvc3RIZWFkcyIsImNvc3RIZWFkcyIsImNvbnRhaW5lckNvdW50IiwiYmFzZVZhbHVlIiwicGVyU2hpcG1lbnRUb3RhbCIsInBlckNvbnRhaW5lclRvdGFsIiwiYnJlYWtkb3duIiwiZm9yRWFjaCIsImNvc3QiLCJpc19hY3RpdmUiLCJkaXNwbGF5QW1vdW50IiwiY2FsY3VsYXRpb25fYmFzZSIsInBlcmNlbnRhZ2VfcmF0ZSIsInBhcnNlRmxvYXQiLCJiYXNlX2Ftb3VudCIsImNoYXJnZV90eXBlIiwicHVzaCIsIm5hbWUiLCJjaGFyZ2VUeXBlIiwidW5pdEFtb3VudCIsInRvdGFsIiwicGVyU2hpcG1lbnQiLCJyb3VuZFRvVHdvIiwicGVyQ29udGFpbmVyIiwiY2FsY3VsYXRlRXhwb3J0UHJpY2luZyIsInByb2R1Y3QiLCJjb250YWluZXJUeXBlIiwibG9jYWxGcmVpZ2h0UmF0ZSIsInBvcnRIYW5kbGluZ1BlckNvbnRhaW5lciIsImNoYUNoYXJnZXMiLCJjdXN0b21zQ2xlYXJhbmNlIiwiY2VydGlmaWNhdGlvbnMiLCJmcmVpZ2h0UmF0ZSIsImZyZWlnaHRDdXJyZW5jeSIsImZyZWlnaHRDb252ZXJzaW9uUmF0ZSIsImZyZWlnaHRHU1QiLCJlY2djUmF0ZSIsImluc3VyYW5jZVJhdGUiLCJtaW5JbnN1cmFuY2UiLCJiYW5rQ2hhcmdlUmF0ZSIsInByb2ZpdFJhdGUiLCJwcm9maXRUeXBlIiwiZGlzcGxheUN1cnJlbmN5Iiwic2VsZWN0ZWRUaWVyIiwicGFja2FnaW5nQ2hhcmdlcyIsImV4dHJhQ2hhcmdlcyIsInRvdGFsUGFja2FnaW5nQ2hhcmdlcyIsInRvdGFsRXh0cmFDaGFyZ2VzQW1vdW50IiwiY3VzdG9tQ2hhcmdlc1RvdGFsIiwiYmFzZVByaWNlIiwiYmFzZV9wcmljZV91c2QiLCJleEZhY3RvcnlQcm9kdWN0VVNEIiwiZXhGYWN0b3J5UHJvZHVjdElOUiIsImV4RmFjdG9yeUlOUiIsImV4RmFjdG9yeVVTRCIsImxvY2FsRnJlaWdodFBlckNvbnRhaW5lciIsImxvY2FsRnJlaWdodFRvdGFsIiwiaGFuZGxpbmdDb3N0cyIsImZpbHRlciIsImMiLCJjYXRlZ29yeSIsInBvcnRIYW5kbGluZ1RvdGFsIiwiY2hhVG90YWwiLCJjdXN0b21zVG90YWwiLCJwb3J0Q29zdHMiLCJoYW5kbGluZyIsImNoYSIsImN1c3RvbXMiLCJtaXNjQ29zdHMiLCJjZXJ0aWZpY2F0aW9uVG90YWwiLCJjZXJ0QnJlYWtkb3duIiwiY2VydCIsImNvc3RfcGVyY2VudGFnZSIsImNvc3RfZmxhdCIsImZvYklOUiIsImZvYlVTRCIsImVjZ2NBbW91bnQiLCJmcmVpZ2h0UGVyQ29udGFpbmVyIiwiZnJlaWdodFRvdGFsRm9yZWlnbiIsImZyZWlnaHRBZGp1c3RlZCIsImZyZWlnaHRJTlIiLCJmcmVpZ2h0R1NUQW1vdW50IiwiZnJlaWdodFdpdGhHU1QiLCJwcmVDaWZCYXNlIiwiaW5zdXJhbmNlQW1vdW50IiwiaW52b2ljZVZhbHVlIiwiYmFua0NoYXJnZXMiLCJjb3N0QmFzZUNJRiIsInByb2ZpdEJhc2UiLCJwcm9maXRBbW91bnQiLCJleEZhY3RvcnlGaW5hbElOUiIsImZvYkZpbmFsSU5SIiwiY2lmRmluYWxJTlIiLCJleEZhY3RvcnlGaW5hbFVTRCIsImZvYkZpbmFsVVNEIiwiY2lmRmluYWxVU0QiLCJjb250YWluZXJDb2RlIiwiY29kZSIsInRpZXJMYWJlbHMiLCJleEZhY3RvcnkiLCJmb2IiLCJjaWYiLCJpbnIiLCJ1c2QiLCJiYXNlSW5yIiwiYmFzZVVzZCIsInBlclVuaXQiLCJwcm9kdWN0QmFzZSIsImxhYmVsIiwibG9jYWxGcmVpZ2h0IiwiY29udGFpbmVycyIsInBvcnQiLCJtaXNjIiwiaXRlbXMiLCJlY2djIiwicmF0ZSIsImZyZWlnaHQiLCJjdXJyZW5jeSIsImZvcmVpZ25Ub3RhbCIsImNvbnZlcnNpb25SYXRlIiwiaW5yVG90YWwiLCJnc3RSYXRlIiwiZ3N0QW1vdW50IiwidG90YWxXaXRoR1NUIiwiaW5zdXJhbmNlIiwicHJvZml0IiwidHlwZSIsInN1bW1hcnkiLCJwZXJTaGlwbWVudENvc3RzIiwicGVyQ29udGFpbmVyQ29zdHMiLCJleGNoYW5nZSIsImVmZmVjdGl2ZSIsInZhbHVlIiwicm91bmQiLCJmb3JtYXRJTlIiLCJJbnRsIiwiTnVtYmVyRm9ybWF0Iiwic3R5bGUiLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJmb3JtYXQiLCJmb3JtYXRVU0QiLCJmb3JtYXROdW1iZXIiLCJudW0iLCJmb3JtYXRQZXJjZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/lib/calculator.js\n"));

/***/ })

});